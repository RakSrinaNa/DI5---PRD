\documentclass[final]{polytech/polytech}

\schooldepartment{di}
\typereport{prddi5}
\reportyear{2018-2019}

\title{Amélioration d'un protocole de rechargement de capteurs}
%\subtitle{}

\student{Thomas}{Couchoud}{thomas.couchoud@etu.univ-tours.fr}
\academicsupervisor{Tifenn}{Rault}{tifenn.rault@univ-tours.fr}

\addbibresource{biblio.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\resume{Projet de fin d'études visant à améliorer un algorithme de recharge de capteurs. Ce dernier devra prendre en compte le rechargement à la demande point-à-multipoint et plusieurs chargeurs tout en évitant les problèmes liés à l'agrégation des champs électromagnétiques. Les améliorations proposées seront ensuite testées et étudiées dans un simulateur qui sera conçu.}
\motcle{radiation électromagnétique, programmation en nombres entiers, chargeur mobile, capteur, problème du voyageur de commerce, voyageur de commerce à fenêtre multiples, transfer d'énergie sans contact, PRD}

\abstract{Final year project aiming to improve an algorithm to charge sensors. It should take into account the on point-to-multipoint demand charging and the problematic of the aggregation of electromagnetic radiations. Those improvements will be tested in a simulator that will be created.}
\keyword{electromagnetic radiations, integer linear programming, mobile charger, sensor, travelling salesman problem, travelling salesman problem with multiple time windows, wireless energy transfer, PRD}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newacronym{emr}{EMR}{electromagnetic radiation}
\newacronym{wet}{WET}{wireless energy transfer}
\newacronym{mc}{MC}{mobile charger}
\newacronym{tsp}{TSP}{travelling salesman problem}
\newacronym{tspmtw}{TSPMTW}{travelling salesman problem with multiple time windows}
\newacronym{ilp}{ILP}{Integer Linear Programming}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\posterblock{Contexte}{
\begin{itemize}
  \item Utilisation de chargeurs sans fils afin de recharger un cluster de capteurs.
  \item Contraintes sur le rechargement:
  \begin{itemize}
  	\item Chargement à distance
  	\item Chargement point à multipoint
  	\item Chargement à la demande
  	\item Pris en compte de contraintes d'ondes électromagnétiques
  \end{itemize}
\end{itemize}
}{Images/contexte.png}{Environnement de capteurs avec un chargeur}

\posterblock{Objectifs}{
Le projet reprenant un papier de Mme Rault a pour but de partir d'une solution déjà proposée pour le problème et de l'améliorer.
Afin de valider les propositions de changement un simulateur devra être réalisé.
}{Images/Changes.png}{Changements proposés}

\posterblock{Mise en \oe uvre}{
\begin{itemize}
	\item Utilisation d'OR-Tools
	\begin{itemize}
		\item Résolution de TSP \& TSPMTW
	\end{itemize}
	\item Développé en JAVA
	\item Permet de définir ses propres types de capteurs, chargeur, algorithmes de routage et plus encore
\end{itemize}
}{Images/UI2.png}{Carte du simulateur}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\weeklyreport{23/09/2018}{
\begin{itemize}
	\item Réception et lecture du papier de Mme Rault \cite{Rault:chargers}.
	\item Echange avec Mme Rault sur le sujet.
    \item Lecture de certaines références.
    \item Réalisation d'un petit résumé de la compréhension ainsi que des premières améliorations possibles (\autoref{fig:changes}).
\end{itemize}
}

\weeklyreport{30/09/2018}{
Avancement:
\begin{itemize}
	\item Mise en place de Biber pour le rapport.
	\item Début du rapport avec notamment la partie contexte \& état de l'art.
\end{itemize}

Questions:
\begin{itemize}
	\item Découpage des différentes parties dans le rapport étant donné qu'il est plus axé recherche.
\end{itemize}
}

\weeklyreport{07/10/2018}{
Avancement:
\begin{itemize}
	\item Ajout des parties manquantes dans l'introduction.
	\item Ecriture de la partie << Description générale >>.
	\item Début du rapport avec notamment la partie contexte \& état de l'art.
\end{itemize}

Questions:
\begin{itemize}
	\item Découpage des différentes parties dans le rapport étant donné qu'il est plus axé recherche.
\end{itemize}
}

\weeklyreport{14/10/2018}{
Avancement:
\begin{itemize}
	\item Avancement sur la partie contexte \& état de l'art.	
\end{itemize}

Questions:
\begin{itemize}
	\item Langage de codage imposé?
\end{itemize}
}

\weeklyreport{21/10/2018}{
Avancement:
\begin{itemize}
	\item Finalisation contexte et état de l'art.
	\item Début d'un peu de code (parsing fichier entrée) pour se changer les idées.
	\item Rédaction des spécifications.
\end{itemize}
}

\weeklyreport{28/10/2018}{
Avancement:
\begin{itemize}
	\item Avancement sur la partie analyse.
\end{itemize}
}

\weeklyreport{11/11/2018}{
Avancement:
\begin{itemize}
	\item Ecriture de l'algorithme \autoref{alg:algorithm1}.
	\item Test de la librairie OR-Tools avec un TSP.
	\item Début d'implémentation de l'algorithme de Mme Rault \cite{Rault:chargers} dans le simulateur.
\end{itemize}
}

\weeklyreport{18/11/2018}{
Avancement:
\begin{itemize}
	\item Analyse logicielle.
	\item Avancement dans le code.
\end{itemize}
}

\weeklyreport{25/11/2018}{
Avancement:
\begin{itemize}
	\item Continuation de l'implémentation de l'algorithme de Mme Rault \cite{Rault:chargers} dans le simulateur.
\end{itemize}
}

\weeklyreport{02/12/2018}{
Avancement:
\begin{itemize}
	\item Adaptation du rapport suite à une échange avec Mme Rault.
	\item Début d'ajout d'une métrique dans le simulateur.
\end{itemize}
}

\weeklyreport{09/12/2018}{
Avancement:
\begin{itemize}
	\item Finalisation du rapport pour le S9.
	\item Création du support de présentation pour la soutenance.
\end{itemize}
}

\weeklyreport{15/12/2018}{
\begin{itemize}
	\item Soutenance.
\end{itemize}
}

\weeklyreport{23/12/2018}{
Avancement:
\begin{itemize}
	\item Début d'ajout du TSPMTW.
\end{itemize}
}

\weeklyreport{13/01/2019}{
Avancement:
\begin{itemize}
	\item Ajout du TSPMTW.
	\item Fix du TSP.
\end{itemize}
}

\weeklyreport{20/01/2019}{
Avancement:
\begin{itemize}
	\item Début de la création d'une interface.
\end{itemize}
}

\weeklyreport{20/01/2019}{
Avancement:
\begin{itemize}
	\item Corrections sur le TSP \& TSPMTW.
	\item Ajout d'une carte dans l'interface.
\end{itemize}
}

\weeklyreport{27/01/2019}{
Avancement:
\begin{itemize}
	\item Ajout de nouvelles métriques.
	\item Amélioration de la carte.
\end{itemize}
Problème:
\begin{itemize}
	\item Le rapport ne compile plus à cause d'un package qui a eu une mise à jour. Réparation OK.
\end{itemize}
}

\weeklyreport{03/02/2019}{
Avancement:
\begin{itemize}
	\item Correction de problèmes où la map n'affichait pas correctement le statut de certains éléments.
	\item Correction de NullPointerExceptions lors de la mise à jour des zones en conflit.
	\item Un chargeur charge tous les capteurs dans son rayon.
	\item Ajout d'états supplémentaires dans la map lorsqu'un chargeur est en train de charger et lorsqu'un chargeur est en cours de déplacement.
	\item Ajout d'animations dans la map.
	\item Chargement des métriques depuis le fichier de configuration.
\end{itemize}
}

\weeklyreport{10/02/2019}{
Avancement:
\begin{itemize}
	\item Le simulateur n'a plus de champs statiques ce qui permet d'avoir un environnement isolé par réplication.
	\item Ajout d'un argument pour lancer la simulation sans UI.
	\item Ajout d'un paramètre pour lancer plusieurs réplications à la fois.
\end{itemize}
}

\weeklyreport{17/02/2019}{
Avancement:
\begin{itemize}
	\item Correction d'un problème où certaines requêtes Lc n'étaient pas traitées.
	\item Ajout de tests.
	\item Build automatique de la Javadoc.
\end{itemize}
}

\weeklyreport{03/03/2019}{
Avancement:
\begin{itemize}
	\item Arrête OR-Tools si le temps de calcul est trop long (permet d'éviter les blocages de ce dernier).
	\item Exécutions de simulation pour obtenir des premiers résultats.
\end{itemize}
}

\weeklyreport{10/03/2019}{
Avancement:
\begin{itemize}
	\item Ajout de métriques supplémentaires.
	\item Correction d'un problème avec le rapport qui ne compilait plus.
	\item Amélioration d'OR-Tools en définissant un espace de recherche réduit.
	\item Ecriture du cahier de tests.
	\item Ecriture de la partie guide d'utilisation.
	\item Complétion de la partie guide d'installation.
\end{itemize}
}

\weeklyreport{17/03/2019}{
Avancement:
\begin{itemize}
	\item Finalisation de la documentation Javadoc.
	\item Finalisation du cahier développeur.
	\item Ajout du poster.
\end{itemize}
}

\weeklyreport{24/03/2019}{
Avancement:
\begin{itemize}
	\item utilisation du simulateur pour générer des résultats.
	\item Correction d'une métrique d'évènement ne contenant pas la bonne valeur.
	\item Correction d'un problème lié au routing.
	\item Ecriture de la partie mise en \oe uvre.
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\class}[1]{\textbf{#1}\label{class:#1}}
\newcommand{\klass}[1]{\hyperref[class:#1]{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\chapter{Introduction}
	\section{Contexte}
		Nous vivons aujourd'hui dans une société dans laquelle la collecte d'information occupe une place de plus en plus importante.
		Cette collecte peut notamment se faire par le biais de capteurs installés à différents endroits.
		
		
		Dans une quête de quantité et qualité des données, les capteurs peuvent être multipliés pour couvrir une plus grande zone et sont amenés à se retrouver dans des environnements très différents afin d'être au plus proche de la source d'information.
		
		Du fait de leur petite taille, un moyen d'assurer leur adaptation à la diversité des emplacements consiste à les alimenter par le biais de batteries.
		Ce choix technique induit cependant des contrainte énergétique concernant le rechargement de ces dernières.
		Cette problématique de recharge de capteurs au sein d'un réseau a récemment gagné une attention considérable dans la communauté scientifique.
		
		En effet les technologies de transfert d'énergie sans fil (\gls{wet}) offrent de nouvelles solutions afin d'adresser le problème.
		Deux options s'offrent à nous, recharger en mode point-à-point ou point-à-multipoint.
		\begin{easylist}[itemize]
			@ \textbf{Point-à-point}: ce mode permet de charger directement un capteur en approchant le chargeur à une distance faible.
			Dans ce cas le rechargement est a son efficacité maximum.
			@ \textbf{Point-à-multipoint}: ce procédé nous autorise à charger plusieurs capteurs avec le même chargeur.
			Tous les capteurs se trouvant dans un certain rayon autour du chargeur seront affectés.
			Cela permet des temps de chargements plus courts et moins de déplacements.
		\end{easylist}
	
		Selon les choix des outils mis en place et la politique de rechargement voulu, nous arrivons à distinguer différentes approches afin de définir le chemin que le(s) chargeur(s) devront emprunter.
		\begin{easylist}[itemize]
			@ \textbf{Rechargement périodique}: le chargeur va effectuer de manière périodique une route optimale pré-configurée.
			Certes le chemin est optimal cependant cela implique que nous connaissons à l'avance l'état et la structure du réseau de capteurs.
			@ \textbf{Rechargement à la demande}: ce procédé corrige le défaut précédent en établissant des routes à la volée.
			En effet, chaque capteur notifie dès qu'il veut être rechargé et le chemin du chargeur sera adapté à la demande.
			Cela permet ainsi de s'adapter à des réseaux plus dynamiques.
			@ \textbf{Rechargement collaboratif}: dans ce cas de figure, le but est de prendre en compte plusieurs chargeurs.
			Il est donc ici question de paralléliser les rechargements de manière efficace afin de pouvoir supporter des réseaux de plus grande taille. 
		\end{easylist}
	
		Cependant comme dit précédemment, il existe la technologie point-à-multipoint.
		Cette dernière, certes pratique, introduit une nouvelle contrainte à cause de son utilisation de radiations électromagnétiques (\gls{emr}).
		Ces rayonnements représentent un potentiel risque de santé si leur intensité dépassent un certain seuil de sécurité.
		Si une telle technologie est utilisée, notamment combiné avec le rechargement collaboratif, il est nécessaire de tenir compte de cette problématique.
		
	\section{Objectifs}
		Ce projet de fin d'études a pour but de reprendre un papier réalisé par Mme Rault \cite{Rault:chargers}, enseignante-chercheuse de Polytech'Tours, afin d'étudier les améliorations possibles à la solution proposée.
		Ce dernier décrit une solution afin de générer des tournées de \glspl{mc} de type point-à-multipoint dans un réseau de capteurs à la demande tout en tenant compte des \glspl{emr}.
		
		Cela passe par une première phase d'analyse du sujet ainsi que de la solution apportée par le papier.
		Une deuxième phase aura pour but de repérer les différents éléments pouvant améliorer l'algorithme actuel.
		
		Ces changements se concrétiserons au travers d'un simulateur qui sera pensé et réalisé afin d'exécuter différents scénarios et en obtenir des métriques sur le système.
	
	%\section{Hypothèses}
	
	\section{Bases méthodologiques}
		Afin de mener a bien le projet, différents outils vont être utilisés.
		
		\begin{easylist}
			@ La réalisation du projet se déroulera au travers d'une méthode Agile.
			En effet cette méthode permet de réaliser des << sprints >> de manière régulière dans lesquelles un livrable est réalisé à la fin.
			Ce choix permet ainsi d'avoir un retour rapide sur notre rythme d'implémentation des fonctionnalités et permet une adaptabilité plus flexible à la demande.
			De plus avoir des livrables de manière régulière me paraît important afin d'obtenir des impressions de la part des utilisateurs tout au long de la réalisation.
			
			@ Concernant la planification des tâches, cela se fera au travers d'un système de << cartes >>.
			Chaque carte contient un objectif précis ainsi qu'une date limite de réalisation.
			
			Ce choix me parait approprié car il est facile de mélanger des tâches plus théoriques avec des tâches plus pratiques.
			En effet on définit toutes les cartes (tâches) du projet dès qu'on les connait, les tâches théoriques (recherche, spécification, ...) auront une date de fin connue dès le départ tandis que les tâches techniques seront récupérées par groupes lors de la composition d'un sprint.
			Les tâches retenues pour former ce groupe dépendra ainsi des retours précédents ainsi que des priorités du client.
			
			Cette gestion et découpage est détaillé en \autoref{sec:plannification}.
			
			@ L'hébergement du code se fera sur un dépôt Git.
			Dans mon cas j'ai préféré me tourner vers \href{https://gitlab.com}{Gitlab}.
			Ce service permet de garder une trace de tout le code réalisé dans le temps.
			Cela est notamment utile si l'on veut revenir en arrière dans le code si un problème majeur survient.
			
			De plus cet hébergeur met aussi à disposition un outil CI (Continuous integration).
			Si le temps me le permet il sera utile de le déployer afin d'automatiser la compilation et les tests.
			
			@ Enfin le rapport sera écrit en \LaTeX~en suivant \href{https://gitlab.com/MrCraftCod/polytechlatex}{la classe plolytech}.
		\end{easylist}
			
\chapter{Description générale}
	\section{Environnement}
		La réalisation du simulateur va impliquer de coder l'algorithme détaillé dans le papier de Mme Rault \cite{Rault:chargers}.
		De ce fait la résolution du \gls{tsp} et \gls{tspmtw} vont devoir être réalisés.
		Afin de ne pas perdre de temps sur la résolution de ces problèmes connus, une librairie sera utilisée.
		L'une d'entre elle est \href{https://developers.google.com/optimization/}{OR-Tools} développée par Google.
		Cette dernière est disponible dans les langages Python, C++, C\# ou bien Java ce qui permet de ne pas bloquer notre choix du langage.
		
		A la vue de cette liberté et du fait que la solution sera utilisé sur une multitude de postes potentiellement très différents les uns des autres, il peut être préférable de choisir un langage tel que Python ou Java afin d'améliorer la portabilité du simulateur sur différents systèmes d'exploitation.
	
	\section{Utilisateur\label{sec:users}}
		Le simulateur est réalisé à destination de chercheurs dans le domaine des capteurs sans fil.
		Même si certains d'entre eux peuvent avoir des connaissances en informatique on ne peut généraliser cela à toute la population concernée.
		Il faudra donc réaliser le programme afin qu'il soit utilisable de la manière la plus simple possible, tout en permettant aux utilisateurs un peu plus avancés de personnaliser le simulateur de manière plus poussée.
		
		\begin{center}
			\centering
			\begin{tabularx}{\textwidth}{|X||X|X|X|X|}
				\hline
				& Connaissance de l'informatique & Expérience de l'application & Type d'utilisateur & Périmètre d'action\\\hline\hline
				Chercheur sans connaissances informatiques & Non & Non & Utilisation des fonctionnalités basiques de manière régulière ou ponctuelle & Lancer des simulations avec un algorithme donné mais possibilité de changer les paramètres de la simulation\\\hline
				Chercheur avec connaissances informatiques & Oui & Non & Utilisation complète de l'application de manière régulière ou ponctuel & Lancer des simulation avec différents paramètres et implémenter son propre algorithme de routage des différents chargeurs.\\\hline
			\end{tabularx}
			\captionof{table}{Caractéristiques utilisateurs}
		\end{center}

	
	\section{Fonctionnalités}
		Le diagramme de cas d'utilisation est disponible ci-dessous (\autoref{fig:usecase}).
		\img[usecase]{UseCase.png}{Diagramme de cas d'utilisation}{}
		
		On peut y observer les deux rôles vu dans la \autoref{sec:users} ainsi que le système.
		
		Le chercheur sans connaissances informatiques va pouvoir effectuer les actions de base:
		\begin{easylist}[itemize]
			@ Modifier les paramètres de la simulation.
			On y retrouve tout ce qui touche au capteurs ainsi qu'aux chargeurs.
			En voici une liste non exhaustive:
			@@ Nombre de capteurs.
			@@ Propriétés par << type >> de capteur:
			@@@ Capacité maximale.
			@@@ Puissance minimum de réception.
			@@ Nombre de chargeurs.
			@@ Propriétés par << type >> de chargeur:
			@@@ Capacité.
			@@@ Vitesse maximale.
			@@@ Fonction de la consommation pour le trajet.
			@@@ Fonction de l'efficacité du chargement.
			@@@ Puissance de transmission.
			@@@ Rayon d'action.
			@@ Méthode de routage.
			
			@ Une fois les paramètres réglés, l'utilisateur aura la possibilité de démarrer/arrêter la simulation.
			
			@ Lorsque la simulation est terminée, les différentes métriques pourront être visualisées directement dans l'interface.
			On y retrouve par exemple:
			@@ Temps de panne des n\oe uds.
			@@ Temps d'attente.
			@@ Énergie dépensée par les chargeurs.
			@@ Distance parcourue.
			
			@ Enfin, afin de ne pas perdre les résultats obtenus il sera possible d'exporter les résultats (métriques obtenues).
		\end{easylist}
		
		Vient ensuite le chercheur avec les connaissances informatiques.
		Nous incluons dans cette catégorie tout ceux qui sont capables de programmer dans le langage de notre application.
		Ces derniers auront les même possibilités que les chercheurs sans connaissances informatiques avec en plus:
		\begin{easylist}[itemize]
			@ Écriture d'algorithmes de routage, capteurs, chargeurs, etc. et enregistrement de ces derniers auprès du système
		\end{easylist}
		
		Enfin le système sera chargé de gérer le déroulement de la simulation:
		\begin{easylist}[itemize]
			@ Tout commence par la lecture et interprétation de la configuration ainsi que des algorithmes de routage.
			@ En fonction de ce qui a été lu, le système exécute la simulation en tenant compte de ce qui a été défini par l'utilisateur.
			@ Enfin les données de la simulation pourront conduire à des métriques qui seront affichées dans l'interface et exportés dans des fichiers.
		\end{easylist}

			
	\section{Structure générale}
		Afin de représenter la structure interne, un diagramme de composant a été réalisé et est disponible ci-dessous.
		
		\img{componentDiagram.png}{Diagramme de composant}{}
		
		On y retrouve 5 composants principaux:
		\begin{easylist}[itemize]
			@ Chargement des données: cette partie aura pour but de lire le fichier de configuration qui est fourni par l'utilisateur afin de rendre ces données accessibles au reste du programme.
			@ Simulation: cette partie a comme objectif de gérer les différents évènements a réaliser. Cela comprend notamment de les ranger dans l'ordre de leur occurrence, éventuellement priorité ainsi que générer les évènements de début/fin.
			@ Exécution/création d'évènements: dans cette partie on exécute le code associé à chaque évènement. C'est ici que des modifications sur l'état du système et génération de nouveaux évènements vont être réalisés.
			@ Enregistrement des métriques: A partir de l'exécution des évènements nous pouvons extraire des valeurs sur des métriques; cette partie a pour but d'enregistrer ces dernières afin de pouvoir les synthétiser par la suite.
			@ Écriture des résultats: lors de la fin de la simulation et avec les données des métriques enregistrées, ce composant offrira à l'utilisateur des données plus synthétisées/agrégées afin de faciliter la lecture de ces dernières. On peut par exemple construire un graphique.	
		\end{easylist}

\chapter{État de l'art}
	Nous avons évoqué en introduction que cette problématique de chargement d'un réseau de capteurs avait récemment suscité une attention particulière de la part de la communauté scientifique.
	Cela a donc mené à un certain nombre de papiers couvrant différent cas de résolution.
	Extrait du papier de Mme Rault \cite{Rault:chargers} on peut observer les différents champs couverts:
	
	\begin{center}
		\centering
		\begin{tabularx}{\textwidth}{|c||X|X|X|X|}
			\hline
			Référence & Chargement à la demande & Chargement point-à-multipoint & Chargeurs multiples & Contrainte \gls{emr}\\\hline\hline
			\cite{6275766} \cite{LIN2016381} & non & oui & non & non\\\hline
			\cite{6911792} \cite{1999253} & oui & non & non & non\\\hline
			\cite{KHELLADI201744} & oui & oui & non & non\\\hline
			\cite{LIN201688} \cite{Madhja2015} \cite{wang2013multi} \cite{Jiang2014} & oui & non & oui & non\\\hline
			\cite{7889006} & non & non & oui & non\\\hline
			\cite{NIKOLETSEAS20171} \cite{8051273} \cite{6888920} \cite{7524385} & non & oui & non & oui\\\hline\hline
			\rowcolor{polytechlightblue}
			\cite{Rault:chargers} & oui & oui & oui & oui\\\hline
		\end{tabularx}	
		\captionof{table}{Cas étudiés par d'autres papiers}
	\end{center}
	
	Beaucoup de travaux ont été réalisés sur des combinaisons de paramètres différents mais les recherches combinant tous ces derniers se font rares.
	Le papier de Mme Rault, qui est notre point de départ, propose une solution prenant en compte toutes les contraintes précédentes, c'est à dire générer des routes à la demande pour un réseau de capteurs avec plusieurs chargeurs point-à-multipoint tout en considérant la problématique des \gls{emr}.
	
	Commençons tout d'abord par expliquer la solution proposée par Mme Rault puis nous détaillerons certains éléments qui ont pu être utilisés dans ce papier.
			
	\section{Solution de Mme Rault}
		La solution proposée se découpe comme suit:
	
		\img[globalschema]{schema-global.png}{Enchainement des étapes de la solution}{}
	
		Le point de départ se situe en haut à gauche avec nos différents capteurs.
		La première étape est de proposer un service de chargement à la demande.
		Il est donc nécessaire de collecter des demandes provenant des capteurs.
		Pour cela une solution proposée par \cite{KHELLADI201744} est utilisée.
		Cette dernière repose sur un système où deux messages, $L_r$ et $L_c$, sont émis par les capteurs.
		Lorsque le niveau de batterie de ces derniers tombe en dessous d'un certain seuil ils envoient un signal $L_r$ au point gérant le réseau.
		Ces signaux ne sont pas alarmant et sont donc stockés jusqu'à ce qu'un signal $L_c$ d'un capteur est reçu.
		Ce dernier indique un niveau plus critique d'une batterie et nous lançons alors la génération d'une nouvelle tournée de rechargement.
	
		La génération des routes se fait en trois étapes:
	
		\begin{easylist}[itemize]
			@ Les différents capteurs sont clusterisés, c'est à dire répartis dans plusieurs groupes, en fonction du rayon d'action $R_c$ des \gls{emr}.
			Ces derniers sont formés d'une manière à minimiser le nombre points d'arrêts que le véhicule aura a effectuer \cite{KHELLADI201744}.
			Minimiser le nombre d'arrêts nous permet de générer des clusters rechargeant le maximum de capteurs à la fois.
			
			Une fois ces points d'arrêt définis, il nous faut les affecter à l'un des chargeurs disponibles.
			Pour ce faire nous commençons par assigner un premier point de passage, tiré aléatoirement, à chaque chargeur.
			Ensuite nous sélectionnons le chargeur avec le moins de temps accumulé (somme des temps de recharge) et lui affectons le point de passage le plus proche n'étant pas déjà assigné.
			De ce fait nous minimisons le temps de voyage tout en équilibrant les temps de recharge entre les chargeurs.
			
			@ Maintenant que nous avons les différents points de passage pour chaque chargeur il nous faut leur donner un ordre.
			C'est ici que notre contrainte des \gls{emr} a une grande influence.
			En effet lors du calcul de ces routes nous devons nous assurer qu'il n'y ait aucun chargeur qui rentre en conflit avec un deuxième.
			
			Pour prendre cela en compte, nous introduisons la notion de points de chargement en conflit.
			Deux points $i$ et $j$ sont en conflits si $dist\left(i,j\right)<R_{c_i}+R_{c_j}$.
			Notre problème se ramène donc à calculer nos routes de manière à ce que deux points en conflit ne soient pas chargés en même temps.
			
			@@ La solution proposée consiste à calculer dans un premier temps un premier \gls{tsp} sur les points d'un premier chargeurs.
			La fonction objectif de ce \gls{tsp} est de minimiser la distance parcourue.
			
			@@ Dans un second temps nous calculons les routes des autres chargeurs séquentiellement grâce à un \gls{tspmtw}.
			Les fenêtres de temps sont calculés en retirant pour chaque zones de conflit les moments où un autre chargeur est présent.
			Ainsi pour chaque chargeur $i$ passant par un point de conflit, nous modifions la fenêtre de temps $W_j$ par $W_j\leftarrow W_j\prive{\left[a_i-t_j, a_i+t_i\right]}$ où $a_x$ re présente la date d'arrivé du chargeur $x$ sur le point et $t_x$ le temps d'arrêt du chargeur $x$ au point.
			Le \gls{tspmtw} est ensuite lancé avec pour but de minimiser le temps de trajet.
			
			En effet il nécessaire de minimiser le temps d'attente au niveau des points de conflit.
			Si le \gls{tspmtw} à pour objectif de minimiser la distance, il est fort possible qu'un conflit apparaisse ce qui entrainera un temps d'attente.
			Il est plus profitable de parcourir un peu plus de distance et commencer à charger un cluster plutôt que d'attendre que la zone se libère.
		\end{easylist}
		
	\section{Génération des clusters\label{sec:clustering}}
		La génération des clusters est un point important dans l'algorithme.
		En effet c'est ce dernier qui va définir les points d'arrêt de nos \glspl{mc}.
		Il est donc nécessaire d'optimiser cette partie afin de ne pas se retrouver dans un cas où le chargeur recharge les capteurs un par un (la fonction du chargement point-à-multipoint serait annulée).
		
		Afin d'obtenir une solution efficace, le papier \cite{KHELLADI201744} propose de minimiser le nombre de ces points d'arrêt.
		 En effet, plus cette donnée est minimale, plus l'on a regroupé les chargeurs entre eux.
		 
		 Le problème est posé comme suit:
		 
		 Soit $\mathcal N$ l'ensemble des n\oe uds ayant effectués une requête. On pose $\abs{\mathcal N} = n$.
		 Chaque capteur $i$ dispose dispose d'un disque dans lequel le chargeur peut être placé afin de recharger ce dernier, on le note $D_i$.
		 
		 Il est a noter que dans cet algorithme on suppose que le rayon du disque de rechargement du \gls{mc} est constant.
		 
		 Afin de déterminer les points d'arrêts, il faut déterminer des intersections entre les différents disques.
		 Le problème revient donc à trouver le minimum de zones d'intersections tel que tout les disques appartiennent à au moins l'une de ces zones.
		 
		 Ces régions $R_j$ sont définies par l'intersection de plusieurs disques $D_i$ ou bien par un disque $D_i$ lui même.
		 On obtient alors $\mathcal N_j=\bigcup_{i=1}^n\left\{i|R_j\cap D_i\neq 0\right\}$ l'ensemble des n\oe uds participant à une zone d'intersection.
		 On a aussi $\mathcal N=\bigcup_{j=1}^m\mathcal N_j$ du fait que chaque n\oe ud doit participer à une intersection.
		 
		 La résolution du problème se fait en posant deux nouvelles variables:
		 
		 $A=\left[a_{i,j}\right]$ un matrice $n\times m$ où $a_{i,j}=\left\{\begin{array}{ll}
		 	1 & \text{si le n\oe ud } i \in \mathcal N_j\\
		 	0 & \text{sinon}
		 \end{array}\right.$.
		 
		 $x_j$ variable binaire de décision telle que $x_j=\left\{\begin{array}{ll}
		 	1 & \text{si la zone } R_j \text{ est dans le chemin minimum}\\
		 	0 & \text{sinon}
		 \end{array}\right.$.
		 
		 La fonction objectif devient alors $\min\sum_{j=1}^mx_j$ (on minimise le nombre de zones d'arrêt) avec une contrainte: $\sum_{j=1}^ma_{i,j}x_j\geq 1; \forall i\in \left\{1, \dots ,n\right\}$ (chaque chargeur appartient à au moins une zone d'arrêt faisant parti du chemin considéré).
		 
	\section{TSP}
		Le \gls{tsp} \cite{wiki:tsp} est un problème très connu dans la communauté scientifique concernant l'optimisation combinatoire.
		Il pose la question suivante: << Ayant une liste de villes et connaissant les distances entre elles, quelle est la plus courte distance telle qu'un voyageur visite chaque ville une seule fois et revienne à sont point de départ? >>.
		De manière parallèle on peut aussi s'intéresser au chemin tel que le temps de parcours est le minimum.
		Cela s'applique bien à notre problème, les villes correspondent aux différents points d'arrêt et le voyageur est un \gls{mc}.
		
		Ce problème fait cependant partie de la classe NP-difficile.
		C'est à dire qu'il n'existe pas d'algorithme déterministe s'exécutant en temps polynomial.
		Il y a donc un choix à faire quant aux solutions que nous voulons obtenir: peu de temps de calcul mais une solution qui peut être loin de l'optimal, ou beaucoup de temps de recherche avec une solutions plus proche de l'optimal.
		
		Dans notre cas nous devons réaliser la tournée de nos \glspl{mc} de manière rapide, le premier choix sera donc de préférence.
		
		Le problème se traduit par un modèle \gls{ilp}.
		On numérote les villes $1, \dots, n$ et définissons $x_{i,j}=\left\{\begin{array}{ll}
				1 & \text{il existe un chemin de } i \text{ à }j\\
				0 & \text{sinon}
			\end{array}\right.$.
			
		Pour tout $i,j\in\left[1,\dots,n\right]$ on pose $u_i$ une variable muette et $c_{i,j}$ la distance entre la ville $i$ et $j$.
		Le problème aura pour fonction objectif:
		\begin{align}
			\label{eq:eq1}
			\min\sum_{i=1}^n\sum_{j=1\atop j\neq i}^n c_{i,j}x_{i,j}
		\end{align}
		
		Avec comme contraintes:
		\begin{align}
			\label{eq:eq2}
			0 \leq x_{i,j} &\leq 1 &&\\
			u_i&\in\zz &&\nonumber \\
			\label{eq:eq3}
			\sum_{i=1\atop i\neq j}^n x_{i,j} &= 1 && \forall j\in \left\{ 1, \dots , n\right\}\\
			\label{eq:eq4}
			\sum_{j=1\atop j\neq i}^n x_{i,j} &= 1 && \forall i\in \left\{ 1, \dots , n\right\}\\
			\label{eq:eq5}
			u_i-u_j+nx_{i,j}&\leq n-1 && 2\leq i\neq j\leq n \\
			\label{eq:eq6}
			0\leq u_i &\leq n-1 && 2\leq i\leq n
		\end{align}
		
		L'\autoref{eq:eq1} définit notre fonction objectif cherchant à minimiser la distance parcourue.
		Si l'on veut changer la métrique à réduire, il suffit de changer ce que représente $c_{i,j}$.
		Dans notre cas cela pourrait être le temps de parcours entre deux n\oe uds.
		
		L'\autoref{eq:eq2} nous permet de restreindre $x_{i,j}$ aux valeurs $0$ et $1$ (on est en nombre entiers).
		
		Les équations \autoref{eq:eq3} et \autoref{eq:eq4} comptent respectivement le nombre de chemins sortants ou entrant sur un n\oe ud donné.
		Ces deux valeurs doivent être égal à $1$ pour n'avoir qu'un seul chemin passant par chaque point.
		
		Enfin les équations \autoref{eq:eq5} et \autoref{eq:eq6} assurent qu'il n'y ait qu'un seul chemin parcourant l'ensemble des n\oe uds (et non pas plusieurs chemins disjoints).
		
	
	\section{TSPMTW}
		Le \gls{tspmtw} est similaire au \gls{tsp} mais introduit une contrainte supplémentaire.
		Le << MTW >> supplémentaire dans le nom indique << multiple time window >> soit << fenêtre de temps multiple >> et c'est sur ce concept que la contrainte supplémentaire va se baser.
		
		Le principe est de définir:
		\begin{easylist}
			@ Une (ou plusieurs) fenêtre(s) de temps par n\oe ud dans lesquelles ce dernier est disponible.
			@ Un temps de service $\beta_i$ correspondant au temps d'arrêt nécessaire pour le n\oe ud $i$.
		\end{easylist}

		\img{tspmtw.png}{Illustration d'une fenêtre de temps (\href{https://acrogenesis.com/or-tools/documentation/user_manual/manual/tsp/tsptw.html}{source})}{}
		 
		On peut observer tout en bas du schéma une fenêtre de temps.
		Cette dernière est représenté par une date de début et une date de fin $\left[ a_{i,j}; b_{i,j}\right]$ avec $i$ étant l'indice du n\oe ud et $j$ l'indice de la fenêtre.
		Ainsi en considérant plusieurs fenêtres de temps, l'intervalle de disponibilité d'un n\oe ud devient $\left[ a_i;b_i\right] =\bigcup_j\left[ a_{i,j}; b_{i,j}\right]$.
		
		Dans la timeline on observe deux valeurs: $t_i$ étant la date d'arrivé au n\oe ud et $s_i$ la date de début du service.
		Comme dit précédemment le temps de service correspond à $\beta_i$.
		
		Ainsi le temps total passé au n\oe ud $i$ correspond à la partie supérieure, prenant en compte le temps de service et le temps d'attente de la disponibilité du noeud.
		
		Le \gls{tspmtw} est utilisé dans notre cas afin d'éviter la surcharge des \glspl{emr}.
		En effet, chaque n\oe ud débute avec une fenêtre de temps $\left[ a_i;b_i\right] = \left[ 0; +\infty\right[$.
		À chaque chargement d'un de ces n\oe uds par un chargeur, on retire la fenêtre de temps d'occupation de ce dernier mais aussi des autres n\oe uds qui sont en conflit.
		Nos fenêtres de temps deviennent alors $\left[ a_i;b_i\right] \longleftarrow \left[ a_i;b_i\right] \prive{\left[ s_j - \beta_i;s_j+\beta_j\right]}$, pour tout chargeur $j\neq i$ avec $j$ le chargeur qui vient de faire son service.
		De cette manière nous bannissons au fur et à mesure les moments où les \glspl{emr} nous posent problème.

\chapter{Analyse et conception}
	Dans ce chapitre nous allons nous intéresser à l'analyse de notre problème et à la conception de notre simulateur afin de pouvoir dégager des axes d'amélioration de l'algorithme qui pourront par la suite être testés dans le simulateur.

	\section{Analyse théorique}
		La première étape est donc l'analyse mathématique du problème.
		Si nous reprenons le schéma global de l'algorithme décrit dans le papier de Mme Rault \cite{Rault:chargers} (voir \autoref{fig:globalschema}) on remarque que ce dernier est découpé en plusieurs étapes, lesquelles font appel à leur propre algorithmes.
		Nous avons donc ici des opportunités d'amélioration à plusieurs niveau de manière indépendantes.
		Cependant il ne faudra pas négliger les effets pouvant se produire si l'on combine plusieurs de ces améliorations (deux améliorations positives, mises ensemble, peuvent mener à une dégradation de manière générale).
		
		Nous allons ici détailler plusieurs axes.
		Ces derniers ne seront peut être pas tous testés par la suite.
		
		\subsection{Seuil $L_c$\label{sec:lc}}
			On rappelle que $L_c$ représente le signal critique envoyé par un capteur et déclenche une tournée des chargeurs.
			Nous allons nous intéresser à deux cas extrêmes:
			\begin{easylist}
				@ \textbf{$L_c$ proche de $L_r$ (seuil de demande de rechargement)}: Dans ce cas dès qu'un capteur juge qu'il nécessite d'être rechargé il lancera la tournée des chargeurs.
				Cela aura pour effet d'annuler la collecte d'une liste de capteur pour aller les recharger en groupe.
				Chaque tournée consistera à aller charger un capteur unique.
				Dans notre cas cela n'a que très peu d'intérêt.
				Il sera donc préférable de garder $L_c$ relativement distant de $L_r$ afin de pouvoir constituer des listes de n\oe uds à charger assez conséquentes.
				
				@ \textbf{$L_c$ proche de 0}: Une valeur proche de 0 lancerait les tournées lorsque le capteur est sur le point d'être hors d'usage.
				C'est encore une fois un point que nous souhaitons éviter.
				Il est donc nécessaire de s'écarter du 0 en prenant une marge suffisante pour couvrir le temps que les chargeurs vont mettre pour venir charger notre n\oe ud.
			\end{easylist}
			
			On remarque donc que la valeur de $L_c$ doit faire un compromis entre s'assurer que les pannes des capteurs sont inexistantes (valeur haute) et laisser de la marge pour grouper les appels des différents n\oe uds (valeur basse) tout en évitant toute pannes.
			
		\subsection{Seuil $L_r$}
			$L_r$ représente le seuil auquel un capteur va faire une demande de rechargement.
			De manière similaire avec $L_c$, nous allons nous intéresser au valeurs extrêmes.
			
			\begin{easylist}
				@ \textbf{$L_r$ proche de $L_C$}: De manière évidente c'est la même chose que $L_c$ proche de $L_r$; voir \autoref{sec:lc}.
				@ \textbf{$L_r$ proche de $C_i$ (capacité maximale d'un capteur)}: Cela va avoir pour effet d'enregistrer un n\oe ud comme nécessitant un rechargement alors que la batterie est encore relativement pleine.
				A cause de cet effet on risque de créer des tournées où la totalité des capteurs est présente.
				
				Dans ce cas la notion de << à la demande >> n'a plus de sens et revient à créer une tournée planifiée à l'avance et l'exécuter lors de la réception d'un $L_c$.
				
				Les batteries prendront surement moins de temps à charger mais d'un autre coté elles peuvent aussi être rechargés si elles se trouvent dans le rayon du chargeur lors d'un rechargement d'un n\oe ud voisin même si notre capteur n'avait pas fait de demande.
			\end{easylist}
			
			Tout comme $L_c$, il nous faut garder $L_r$ à une valeur distante de $C_i$ tout en laissant de la marge pour ne constituer des tournées qu'avec des capteurs ayant un réel besoin (et ainsi éviter les déplacements inutiles des chargeurs).
		
		\subsection{Influence du nombre de MCs}
			On peut avoir tendance à penser que plus nous augmentons le nombre de \glspl{mc} plus nous rendons notre système efficace car nous ajoutons de la capacité à traiter les capteurs en parallèle.
			Cependant ce n'est pas toujours le cas.
			Deux raisons expliquent cela:
			\begin{easylist}
				@ En augmentant le nombre de \gls{mc}, on augmente aussi la consommation globale en énergie.
				En effet nous nécessitons de plus d'énergie pour déplacer l'ensemble des chargeurs.
				@ On augmente la complexité des \glspl{tspmtw} vis à vis des \glspl{emr}.
				Cela s'explique par le fait que plus l'on a de chargeurs, plus l'on à d'interférences possible entre ces derniers.
				Il se peut donc qu'avec trop de chargeurs on introduise un nombre conséquent de temps d'attente afin d'éviter des conflits.
			\end{easylist}
			
			Il va donc falloir que nous trouvions un nombre adéquat de chargeurs afin de ne pas surcharger la zone tout en en gardant un nombre suffisant pour pouvoir paralléliser nos rechargements.
		
		\subsection{Rayons de rechargement différents}
			Actuellement l'algorithme proposé ne prend en compte qu'un seul rayon de rechargement pour tous les capteurs.
			Cependant il pourrait être intéressant de considérer des chargeurs ayant des rayons différents.
			Cela pourrait peut-être améliorer dans certains cas l'algorithme de clustering.
			
			A terme cela pourrait réduire le temps d'attente en réduisant le nombre de zones en conflit.
			Cependant cela ajoute une complexité supplémentaire dans la génération de nos clusters.
			
			Il est cependant dans mon opinion pas très intéressant d'explorer cette piste.
			En effet comme précisé dans l'étude de l'art (\autoref{sec:clustering}), on suppose que le disque de rechargement $M$ est constant.
			Une manière simple de travailler avec des rayons différents est de poser $M=\min_{i}M_i$.
			Cette approche ne prend cependant pas avantage des rayons différentes.
			
			Une autre approche consisterai en une exploration de différentes solutions où les différents $M$ de chaque cluster prend une valeur parmi les $M_i$ disponibles.
			On peut imaginer utiliser des algorithmes génétiques ou autres afin de trouver une solution s'approchant de l'optimale.
			Cependant cette façon de procéder rajoute un nombre conséquent de répétitions de l'algorithme de clustering (avec différents $M$).
			L'ajout de cette complexité n'est probablement pas avantageux comparé au gain minime de performance du système que l'on pourrai obtenir.
						
		\subsection{Modification de la fonction objectif des TPSMTWs}
			Un autre point sur lequel nous pouvons influencer est la façon dont sont généré les routes des chargeurs une fois que le premier tracé est défini.
			Nous utilisons pour le moment une fonction objectif minimisant le temps de parcours.
			Cependant on peut envisager de modifier cette dernière pour prendre en compte une combinaison du temps et de la distance.
			
			Les paramètre de la combinaison entre les deux variables reste à déterminer expérimentalement.
			Selon moi cela aura un impact que très minime.
			En effet le fait de minimiser le temps minimise aussi la distance parcourue d'une certaine manière puisque se déplacer prends du temps.
		
		\subsection{Modification de la méthode de clustering}
			La méthode utilisée pour le clustering est un point central concernant l'aspect << point-to-multipoint >> de nos chargeurs.
			En effet c'est ce dernier qui s'occupe de transformer notre liste de capteurs en un nombre réduit de points d'arrêt qui seront utilisés pour notre tournée.
			Cela nous permet d'obtenir un point précis d'arrêt ainsi qui de réduire le nombre d'arrêts.
			
			Actuellement la création de ces régions d'arrêt fait en sorte qu'un capteur se retrouve associé à au moins un point d'arrêt.
			Cependant il peut être aussi faire parti de plusieurs régions à la fois. 
			Cette remarque peut être très intéressante car de cette manière on peut considérer le rechargement d'un capteur depuis plusieurs points d'arrêt.
			
			Cela est utile si l'on a un capteur fortement déchargé entouré de capteurs moyennement déchargés.
			Ainsi on commence par charger une partie des capteurs, dont celui fortement déchargé.
			Dès que les capteurs moyennement déchargés sont complètement chargés, on change de zone pour recharger une autre partie moyennement déchargée tout en continuant le rechargement du capteur fortement déchargé (et qui doit donc être moyennement déchargé à ce moment).
			
			Voici une représentation de la situation.
			On dispose de deux disques (bleu et cyan) qui ont été construits par notre algorithme de clustering.
			Le centre de chacun d'entre eux représente un point d'arrêt.
			
			Les yeux représentes nos différents capteurs (vert: chargés, orange: moyennement déchargés, rouge: fortement déchargés).
			
			Le véhicule rose représente un chargeur.
			
			On peut imaginer le premier état comme étant le rechargement du disque bleu.
			
			\img{multi1.png}{Etat A}{width=10cm}
			
			Enfin lorsque les capteurs orange du disque bleu sont chargés, le véhicule se déplace dans le disque cyan et effectue le chargement.
			
			\img{multi2.png}{Etat B}{width=10cm}
			
			Notre n\oe ud originellement rouge a donc été chargé en deux phases, réduisant ainsi le temps de tournée du véhicule.
			
			Afin de prendre en compte cette appartenance multiple, il nous faut adapter le step 1 du papier de Mme Rault \cite{Rault:chargers} (Fig. 2.).
			La méthode actuelle consiste à prendre pour chaque région $R_j$ $t_j=\max_{i\in R_j}t_{j,i}$ où $t_{j,i}$ représente le temps de charge d'un capteur $i$ appartenant à la région $R_j$.
			
			Afin de prendre en compte le principe de rechargement depuis plusieurs zones, on propose de modifier l'algorithme permettant de calculer le temps d'arrêt d'une région:
			
			\begin{algorithm}[H]
				\caption{Calcul des temps de recharge à chaque point d'arrêt en prenant en compte les n\oe uds présents dans plusieurs régions}
  				\label{alg:algorithm1}
  				\hspace*{\algorithmicindent} \textbf{Input:}
  				The set $S=\left\{1,\dots, m\right\}$ of $m$ regions obtained from the 2 firsts steps of the first step. The set $S_j=\left\{1,\dots ,n_j\right\}$ of $n_j$ sensors inside a region $R_j$ with their charging time $\tau_i$, $\forall i\in S$. $t_i$ is the charging time required by the sensor $i$. The set $K$ which for each sensor contains a set containing each regions the sensor is in.
				\begin{algorithmic}[1]
					\For{$j\in S$}
						\State $P_j\leftarrow \left\{\right\}$
						\State $t_j\leftarrow 0$
						\For{$i\in S_j$}
							\If{$\text{card}\left(K_i\right)>1$}
								\State $P_j\leftarrow P_j\cup\left\{ i\right\}$
								\State $K_i \leftarrow K_i\prive{j}$
							\Else
								\State $\tau_j \leftarrow \max\left( \tau_j, t_i\right)$
							\EndIf
						\EndFor
						\For{$i\in P_j$}
							\State $t_i\leftarrow t_i - \tau_j$
						\EndFor
					\EndFor
				\end{algorithmic}
			\end{algorithm}
			 

		\subsection{Méthode de répartition des points d'arrêts}
			Lors de l'assignement des premiers clusters à chaque chargeur, il peut être intéressant d'utiliser une méthode qui n'est pas aléatoire.
			En effet si l'on se retrouve avec des chargeurs devant aller dans des régions voisines dès le départ n'est peut être pas optimal.
			En revanche répartir ces premières destinations au travers de la zone de capteurs peut améliorer la distance parcourue afin de couvrir cette région entièrement.
		
		\subsection{Eléments d'analyse}
			Nous allons dans un premier temps s'intéresser aux influence des paramètres suivants:
			\begin{easylist}
				@ Seuil $L_c$.
				@ Seuil $L_r$.
				@ Nombre de \glspl{mc}.
				@ Modification de la méthode de clustering.
				@ Modification de la fonction objectif des \glspl{tspmtw}.
			\end{easylist}
			
	\section{Analyse logicielle}
		Afin de réaliser la partie logicielle, c'est à dire le simulateur, on propose de suivre un diagramme de classe similaire à celui ci-dessous.
		
		\img{ClassDiagram.png}{Diagramme de classes simplifié}{}
		
		On y retrouves trois parties principales:
		\begin{easylist}[itemize]
			@ Configuration: rassemble toutes les classes qui serviront à paramétrer notre simulateur.
			@ Simulator: contient tout les éléments liés à la simulation cela passe par chargeurs, capteurs, systèmes de routage mais aussi par des évènements qui permettront de faire avancer la simulation.
			@ Metrics: concerne toute la partie de collecte des informations sur le système afin de les restituer et agréger par la suite. 	
		\end{easylist}

		\subsection{Configuration}
			\img{config.png}{Partie configuration}{}
			
			La partie configuration va comporter une classe principale permettant de lire un fichier JSON qui mettra par la suite un objet Environment disponible au travers d'un getter.
			Ce chargement de paramètres doit être dynamique en autorisant l'instantiation de classes à partir de leur noms et de paramètres.
			Pour cela on créera une interface << JSONParsable >> permettant à un objet lisible depuis le JSON de récupérer les paramètres dont il a besoin.
			
			Si on problème survient durant la lecture de la configuration, une exception SettingsParserException sera levée en indiquant où se situe le problème.
		
		\subsection{Simulator}
			\img{simulator.png}{Partie simulator}{}
						
			Le diagramme de classes ci-dessus nous montre la partie simulateur dans son état le plus simple -- aucun algorithme de routage n'a été ajouté et les capteur ne font que se décharger.
			
			La partie supérieure concerne le << modèle >> avec les différents éléments de notre environnement (router, charger, sensor).
			Cependant si par la suite nous voulons ajouter des éléments personnalisés, il suffit d'étendre la classe Identifiable et ajouter ces éléments dans l'environnement.
			Nous permettons donc grâce à cette interface une flexibilité sur les éléments de la simulation.
			
			La partie inférieure se focalise plus sur la simulation en elle même avec notre échéancier et les différents évènements qui l'entourent.
			De base seul les évènements Start (début), End (Fin) et Discharge (déchargement des capteurs) sont présents.
			Cependant lors de l'ajout de nouveaux éléments Identifiables, ces derniers pourront créer de nouveaux évènements (SimulationEvent) et le simulateur les traitera aussi.
			Par exemple on créé une classe LrLcSensor qui étend Sensor, et dès que le niveau de batterie est inférieur à $L_r$ ce dernier va créer un évènement LrEvent.
		
		\subsection{Metrics}
			La collecte des métriques est un point important de la simulation et doit permettre de collecter un grand nombres de données.
			
			Pour cela on propose de suivre un design pattern de producteur consommateur.
			Les producteurs seront des éléments de la simulation qui généreront des évènements indiquant un changement dans l'état des variables.
			Les consommateurs vont par la suite consommer ces évènements, ne gardant que ceux qui les intéressent, et traiter ce changement.
			
			Les consommateurs seront aussi responsables d'écrire les résultats dans les différents fichiers de sortie.
			
		\subsection{Diagramme complet}
			Le diagramme de classes complet dans l'état actuel (la partie métriques n'est pas implémentée et l'algorithme de routage non fini) est disponible en \autoref{fig:diagramclass}.
			
		\subsection{Limites}
			La gestion du simulateur sous forme d'évènements impose certaines limites:
			\begin{easylist}[itemize]
				@ Le temps est discret et non continue.
				@ Les temps de calculs des routes n'est pas pris en compte.
				Cette limitation a été est acceptée.
				Si nécessaire il est possible de la contourner en ajoutant un nouvel intermédiaire qui rendra compte de ce temps de calcul.
				@ Du fait du temps discret, les chargeurs chargent en 1 coup les différents capteurs puis attendent un certain temps avant de repartir.
				Cela ne rend pas compte de la réalité qui a un chargement continu.
				Cependant cette approximation nous est suffisante.
				De la même manière cette problématique peut être contournée en ajoutant des évènements intermédiaires.
				
				Des problèmes peuvent survenir si les chargeurs chargent moins vite que la vitesse d'utilisation des batteries par les capteurs.
				Dans ce cas notre approximation serait fausse.
				Cependant un tel système n'aurait aucun sens car la finalité serait un réseau dont tous les capteurs sont déchargés.
			\end{easylist}

	
\chapter{Mise en \oe uvre}
	Le développement du projet s'est effectué avec la méthode agile.
	Il n'y a donc pas de Gantt pour cette partie.
	Tout a été géré au travers d'issues (voir \autoref{sec:issues}) afin de définir les tâches à traiter.
	Ces dernières ont étés par la suite réparties sur les différents sprints prévus en fonction de leur criticité.
	
	Afin d'améliorer la détection de bugs et la construction de fichiers exécutables, un système d'intégration continue a été mis en place et automatise de nombreuses tâches.
	Plus d'informations sur cette partie sont disponibles en \autoref{sec:ci}.
	
	Nous allons dans cette partie nous focaliser sur la réalisation du simulateur ainsi que des résultats que nous avons pu obtenir au travers de ce dernier. 
	
	\section{Simulateur}
		La réalisation de ce simulateur a été découpée en trois étapes majeures:
		\begin{easylist}
			@ Partie c\oe ur: gestion de la configuration, gestion d'évènements du simulateur, gestion de métriques, ...
			@ Ajout de l'algorithme de Mme Rault en étendant le c\oe ur (comme si ce dernier était une librairie).
			@ Implémentation des améliorations proposés à l'algorithme (modification de classes existantes).
		\end{easylist}
		
		\subsection{Développement du c\oe ur du simulateur}
			La partie centrale du simulateur va s'apparenter grandement au diagramme de classes de la \autoref{fig:classDiagramDetailled2} (avec quelques implémentations spécifiques en moins).
			
			\subsubsection{Lecture de la configuration}
				Commençons par la lecture du fichier de configuration.
				En effet ce dernier est notre point d'entré et va définir tout l'environnement de simulation qui sera utilisé par la suite.
				Les éléments dont nous avons besoin sont les suivants:
				\begin{easylist}
					@ Seed de génération des nombres aléatoires
					@ Date de fin de la simulation
					@ Métriques à enregistrer
					@ Eléments présents dans la simulation
				\end{easylist}
				
				Un des objectifs important de notre configuration est que celle-ci soit capable de décrire des instances possiblement très différentes.
				De plus elle doit aussi être robuste a de potentiels ajouts d'éléments dans le code.
				
				Pour cela le format JSON a été choisi.
				Ce dernier permet de définir des structures telles que des listes, objets ou valeurs ce qui est très pratique dans notre cas.
				Le format de ce fichier coté utilisateur est défini en \autoref{sec:jsoninput}. Nous allons ici détailler ce qu'il se passe du point de vue du code.
				
				La lecture des paramètres tels que la seed ou le temps final de la simulation est triviale et ne sera pas décrite. 
				En rechante tous les objets définissants des classes à initialiser méritent une explication.
				Dans le fichier mentionné plus haut cela concerne notamment les capteurs et les chargeurs.
				
				Le principe est de définir une classe qui sera instanciée avec des paramètres.
				Pour cela une interface \klass{JSONParsable} a été crée et définie un élément que nous pouvons parser depuis un objet JSON.
				Il suffit par la suite d'utiliser la réflexivité afin de rechercher la classe nommée, vérifier qu'elle implémente \klass{JSONParseable} et appeler la méthode appropriée afin d'initialiser les paramètres de cette instance.
				
				\javasourcefile[caption=Création d'un JSONParsable depuis le JSON]{Code/jsonParseObject.java}
				
				Les lignes 3 à 9 effectuent la recherche de la classe concernée.
				
				Les lignes 10 à 12 vérifient que la classe trouvée implémente bien \klass{JSONParseable}.
				
				Les lignes 13 à 14 préparent les paramètres qui seront passés à l'instance de la classe.
				
				La ligne 15 va instancier la classe le nombre de fois qui est défini dans le fichier de configuration.
				
				Les lignes 16 à 21 effectuent l'instantiation des classes.
				
			\subsection{Eléments de base}
				Une fois le parser de la configuration réalisé, il a fallu implémenter des objets de base qui seront utilisés lors de la simulation.
				Dans le cas de notre problème nous retrouvons 3 éléments majeurs:
				\begin{easylist}
					@ Les chargeurs.
					@ Les capteurs.
					@ Le système de routage.
				\end{easylist}
				
				Afin de généraliser les éléments cités plus haut, une classe \klass{Identifiable} a été crée.
				Son but est de définir un élément de la simulation qui a une importance (contrairement à un objet \klass{Position}) et donc être capable de l'identifier individuellement.
				A chaque création de l'un de ces objets, un identifiant unique lui sera attribué et pourra être utilisé dans le code afin de le retrouver.
				
				De plus une généralisation des chargeurs et capteurs a aussi été faite au travers de deux interfaces:
				\begin{easylist}
					@ \klass{Rechargeable}: indique que l'élément dispose d'une batterie pouvant être chargée ou déchargée.
					@ \klass{Positionable}: indique que l'élément dispose d'une position.
				\end{easylist}
				
				Tous les éléments peuvent par la suite étendus par d'autres classes afin d'y rajouter des fonctionnalités.
				Nous allons ici détailler les implémentations de bases qui ont été réalisées afin d'avoir le minimum nécessaire pour le simulateur.
				
				\subsubsection{Capteurs}
					Les capteurs implémentent toutes les interfaces précédemment citées: \klass{Identifiable}, \klass{Positionable} et \klass{JSONParseable}.
					
					Ils ont de plus une vitesse de décharge ainsi un seuil d'activation pour être rechargé.
				
				\subsubsection{Chargeurs}
					Les chargeurs implémentent toutes les interfaces précédemment citées: \klass{Identifiable}, \klass{Positionable} et \klass{JSONParseable}.
					
					Ils ont de plus un rayon de recharge, une intensité d'émission des ondes \glspl{emr} et une vitesse.

				\subsubsection{Routeur}
					Un router est juste \klass{Identifiable} et \klass{JSONParseable} et définit une méthode route qui sera à implémenter.
					Il est à noter que le nombre de router par instance est limité à 1 et qu'aucune implémentation de base n'est fournie.
			
			\subsection{Simulateur \& évènements}
				Maintenant que nous avons les différent éléments permettant de définir un environnement (instance), il nous faut les utiliser de manière logique de manière à rendre compte de ce qu'il se passerai dans la réalité.
				
				\subsubsection{Evènements}
					Le principe du simulateur repose sur une gestion ordonnée d'évènements.
					Chaque évènement pourra par la suite modifier l'état des différents \klass{Identifiable}s de la simulation.
				
					Du point de vue du code un évènement contient:
					\begin{easylist}
						@ Une date d'exécution
						@ Une priorité
						@ Un code à exécuter	
					\end{easylist}
					
					Par défaut 3 évènements sont implémentés:
					\begin{easylist}
						@ Start: initialise des variables et ajoute des évènements décharge et fin dans la file du simulateur.
						@ Fin: vide la file du simulateur et nettoie le simulateur.
						@ Décharge: décharge tous les capteurs et ajoute un évènement décharge à $t+1$ dans la file du simulateur.
					\end{easylist}
					
				\subsubsection{Simulateur}
					Le simulateur en lui même effectue toujours les mêmes opérations:
					\begin{easylist}
						@ Initialise son temps d'exécution à 0
						@ Ajoute un évènement Start dans la file au temps 0
						@ Tant que des éléments sont présents dans la queue, extraire l'évènement avec le temps le plus faible et si égalité celui avec la priorité la plus faible (en terme de valeur):
						@@ Modification du temps du simulateur comme étant celui de l'évènement
						@@ Exécution de l'évènement
						@@ Exécution des potentiels évènements de métriques non distribués
						@ Fin
					\end{easylist}
					
					Les évènements seront ajoutés au fur et à mesure que d'autres sont exécutés (par exemple l'évènement décharge qui ajoute une autre décharge en queue).
					La fin du simulateur se situe, d'après la manière d'opérer, lorsque la file du simulateur est vide.
					C'est pour cela que l'évènement fin vide cette file afin de permettre au simulateur de s'arrêter.
					
					Il est à noter qu'un évènement ayant un temps inférieur au temps actuel du simulateur ne peut être ajouté dans la file.
					En effet, cela pourrait mener a des états incohérents.
					
				\subsection{Premiers lancements}
					En ayant implémenté les parties précédentes notre simulateur peut déjà être lancé et effectuer les opérations qui lui sont demandées.
					Dans notre cas cela revient à avoir des capteurs qui vont se décharger de manière constante tout au long de la simulation.
					
					\img{simu1.png}{Première simulation}{}
					
					On peut ici observer un chargeur se faisant décharger de $0.1$ (définit dans la configuration) à chaque unité de temps du simulateur.
					Cela est effectué jusqu'au temps $10$ étant définit comme la fin de la simulation.
					
			\subsection{Métriques}
				Maintenant que notre simulateur est capable d'exécuter nos évènements, il est nécessaire que nous soyons en mesure de récupérer des informations sur ce qu'il se passe afin d'en extraire des métriques.
				Une première solution serait que le simulateur notifie des listeners à chaque évènement traité.
				Cependant cette approche est très restrictive.
				
				En effet si par exemple un évènement modifie la capacité d'un chargeur et sa position en même temps il sera très couteux de maintenir le code pour que les listeners s'adaptent au code de l'évènement.
				De plus si par la suite on ajoute un autre évènement qui décharge des capteurs, nos listeners précédemment créés ne gérerons pas ce cas et nous aurons une dissonance entre le simulateur et ce qui est indiqué dans les sorties des métriques.
				
				Afin de contourner ce problème une autre solution a été mise en place.
				Cette dernière repose sur un système de producteurs/consommateurs.
				Chaque évènement du simulateur va produire des évènements métriques (\klass{MetricEvent}) correspondant aux opérations qu'il effectue (décharge de capteur, changement de position, ...).
				Cet évènement métrique est ensuite envoyé à un dispatcher qui va le redistribuer aux différents consommateurs.
				
				De cette manière le code des listeners de métriques n'est plus dépendant du code d'un évènement.
				Cela permet ainsi d'écouter des évènement plus ciblés et si un nouvel évènement est créé dans le code par la suite, il pourra lui aussi utiliser ces évènements métriques qui seront écoutées par les listeners approprié.
				
				Dans le cas de notre mini-exemple, deux évènements métriques sont présents:
				\begin{easylist}
					@ Décharge d'un capteur: Permet d'indiquer qu'un chargeur en particulier a eu sa capacité de changé.
					@ Décharge de capteurs: Permet d'indiquer qu'au moins un des capteurs a eu sa capacité de changé.
				\end{easylist}
				
				Ces évènements sont créés par l'évènement de décharge:
				\javasourcefile[caption=Evènement de décharge]{Code/mEventDischarge.java}
				
				On peut observer à la ligne 8 la création et envoi de l'évènement métrique décharge d'un capteur.
				De manière similaire la ligne 10 effectue le même traitement lorsque au moins un des capteur a changé de capacité.
 
				Du coté des listeners, ces derniers les reçoivent tous.
				A eux de trier ceux qu'ils veulent garder et les traiter.
				
				Voici un exemple d'un listener qui sauvegarde sous format CSV la capacité des capteurs tout au long de la simulation:
				\javasourcefile[caption=Exemple de MetricEventListener]{Code/mEventListener.java}
				
				Sortie:
				\csvsourcefile[caption=Exemple de sortie de métrique]{Code/capacity.csv}
				
		\subsection{Implémentation de l'algorithme de Mme Rault}
			Maintenant que nous avons un simulateur fonctionnel, il ne reste plus qu'à l'étendre comme si ce dernier était une librairie.
			On va en fait réaliser ce que tout le monde peut faire avec le simulateur du fait de sa grande adaptation.
			
			Nous allons donc devoir implémenter:
			\begin{easylist}
				@ Nos capteurs $L_r$ / $L_c$
				@ Notre système de routage:
				@@ Logique du routage
				@@ TSP
				@@ TSPMTW
				@ Les évènements associés (requête $L_c$, requête $L_r$, début d'une tournée, ...)
				@ Les évènements métrique associés
			\end{easylist}
			
			Les parties suivantes vont détailler les deux premiers points et inclurons les 2 derniers au fur et a mesure.
			
			\subsubsection{Capteur $LrLc$}
				Notre capteur \klass{LrLcSensor} va repartir de l'implémentation basique \klass{Sensor} et y ajouter les éléments propre à ce type de capteur:
				\begin{easylist}
					@ Valeur de $L_c$.
					@ Valeur de $L_r$.
				\end{easylist}
				
				Rien de plus concernant le capteur en lui même.
				Cependant il est nécessaire de créer nos évènements de requêtage au près du serveur de routage.
				Pour cela on attache un \klass{SensorListener} qui va effectuer des actions lorsque le niveau de batterie est modifié:
				\begin{easylist}
					@ Si une requête $L_r$ n'a pas déjà été faite:
					@@ Si on est en dessous du seuil $L_r$:
					@@@ Création d'un évènement \klass{LrRequestEvent}.
					@@@ Enregistrement de la demande.
					@ Si une requête $L_c$ n'a pas déjà été faite:
					@@ Si on est en dessous du seuil $L_c$:
					@@@ Création d'un évènement \klass{LcRequestEvent}.
					@@@ Enregistrement de la demande.
					@ Si une requête $L_r$ a déjà été faite:
					@@ Si on est au dessus du seuil $L_r$:
					@@@ Réinitialisation des demandes.
				\end{easylist}
				
				L'évènement \klass{LrRequestEvent} se contente juste d'enregistrer les capteurs ayant fait des requêtes dans une liste et génère aussi un évènement de métrique \klass{LrRequestMetricEvent}.
				
				L'évènement \klass{LcRequestEvent} va quant à lui générer un évènement de métrique \klass{LcRequestMetricEvent} puis lancer le routing avec le \klass{Router} définit dans l'environnement.
				Si aucun \klass{Router} n'est définit, aucun routing ne sera réalisé.
				
				Il est à noter que si une tournée est déjà en cours de réalisation, il est nécessaire d'attendre que tous les chargeurs soient revenus à la base.
				Dans ce cas l'évènement \klass{LcRequestEvent} est reporté à la date $t+1$.
				
			\subsubsection{Routage}
				Maintenant que nos capteurs effectuent leur requêtes et qu'un routeur est appelé dès que nécessaire, il nous faut maintenant en définir un qui va respecter l'algorithme vu dans les parties précédentes.
				Ce dernier est \klass{RaultRouter} et surcharge la méthode << route >> de sa classe parent \klass{Router}.
				
				Nous allons détailler de manière assez séquentielle ce que le router réalise.
				Il est à noter que certains points diffèrent de la partie théorique et ces derniers seront mentionnés car ils auront une influence assez forte sur les résultats obtenus.
				
				Le routeur commence tout d'abord par obtenir la liste de tous les chargeurs et vérifie que tous sont disponibles.
				Si l'un d'entre eux est toujours occupé cela signifie qu'une autre tournée est toujours en cours de traitement et nous devons donc attendre la fin de cette dernière.
				Dans ce cas le routage n'est pas effectué.
				
				\paragraph{Création des points d'arrêt}
					Si en revanche ils sont disponibles, nous allons créer toutes les structures nécessaires afin de pouvoir effectuer la tournée.
					Cela commence par la création des points d'arrêt.
					En effet l'algorithme ne route pas des capteurs directement mais des zones où le capteur s'arrêtera pour recharger un ou plusieurs capteurs.
					Un point d'arrêt est représenté par \klass{StopLocation} et est composé une coordonnée dans l'environnement ainsi qu'une liste de capteurs présents dans la zone autour de ce point.
					
					\textbf{Une première différence est ici présente}. La théorie repose sur une solution décrite par \cite{KHELLADI201744} et résout un problème de clique minimale.
					Etant donné que cette solution est relativement complexe, cela n'a pas été une priorité pour nous et l'implémentation actuelle est très différente.
					Nous allons considérer que le rayon de recharge est le rayon le plus petit de tous les chargeurs.
					Puis pour chaque capteur à recharger, il définit lui même un point d'arrêt.
					Cela a pour conséquence que le nombre de points d'arrêt n'est pas minimal et certaines zones peuvent être dupliquées, créant aussi des zones de conflict inutiles.
					
					Voici une représentation des différences.
					Chaque \oe uil représente un capteur devant être chargé, les cercles les rayon d'action et chaque centre de ces derniers représentent les points d'arrêt.
					\img{ptsArretGood.png}{Un point d'arrêt qui aurait été généré par l'algorithme théorique}{scale=0.5}
					\img{ptsArretBad.png}{Points d'arrêts générés par notre implémentation}{scale=0.5}
					
				\paragraph{Création des points de recharge}
					Une fois nos points d'arrêt créés, nous allons les faire évoluer en \klass{ChargerStop} qui va représenter un point pour le système de routage.
					Ce dernier contient:
					\begin{easylist}
						@ Un \klass{StopLocation} comme vu précédemment.
						@ Un temps de recharge nécessaire.
						@ Une liste de temps d'indisponibilité.
						@ Une liste de zones en conflict.
						@ Une date d'arrivée du chargeur.
						@ Un chargeur attribué pour ce point.
					\end{easylist}
					
					\textbf{Lors de la création de ces objets nous faisons encore des hypothèses qui vont influencer sur la qualité de nos résultats}.
					En effet pour calculer le temps de recharge nécessaire pour un \klass{ChargingStop}, nous prenons le temps maximum de recharge de tous les capteurs dans la zone.
					Cela a pour effet de ne pas prendre en compte les capteurs étant dans plusieurs zones (et donc chargés deux fois), mais en plus de cela, le temps de recharge d'un capteur est calculé à partir la puissance minimale de recharge des chargeurs.
					Or il est possible que le chargeur qui sera attribué à cette zone ait une puissance plus élevée.
					
					A ce moment, notre objet contient seulement la \klass{StopLocation} ainsi qu'une estimation du temps de recharge nécessaire pour cette zone.
					
				\paragraph{Création des routes}
					Maintenant que nous avons des objets plus précis sur ce qu'est un point d'arrêt, il faut leur assigner un chargeur qui devra s'occuper de cette zone.
					Pour cela nous reprenons exactement la partie théorique.
					Chaque capteur a une zone associé aléatoirement, puis pour les points restant, nous ajoutons au \klass{ChargingStop} ayant le moins de temps accumulé la zone la plus proche.
					
					Tout cela est consigné dans un \klass{ChargerTour} contenant un chargeur et une liste de \klass{ChargerStop} représentant ainsi la route d'un chargeur pour une tournée.
					
					Enfin, les routes sans points d'arrêt (cas où il y a plus de chargeurs que de points d'arrêt à desservir) sont détruits.
					
				\paragraph{Création des zones de conflict}
					Pour chaque \klass{ChargingStop} nous mettons ensuite à jour les zones avec lesquelles il est en conflict.
					A ce moment nous savons quel chargeur va s'occuper de chaque zone, nous utilisons donc le vrai rayon et nous évite ainsi de faire des hypothèses.
					
				\paragraph{Ordonnancement des tours}
					A ce point nous avons chaque chargeur avec la liste de points qu'il devra recharger.
					Il nous faut à présent les arranger dans l'ordre dans lequel nous voulons qu'ils soient visités.
					
					\subparagraph{TSP}
						Dans le cas du premier tour que nous traitons, nous effectuons un simple TSP.
						En effet il n'y a aucune contrainte de fenêtre de temps.
						
						Pour cela nous utilisons la librairie OR-Tools.
						Nous allons expliquer de manière synthétique comment cette dernière est utilisée.
						
						\javasourcefile[caption=TSP,label=code:tsp]{Code/TSP.java}	
						
						La ligne 5 permet de définir un model de routing.
						Les paramètres sont les suivants:
						\begin{easylist}
							@ Le nombre de points: dans notre cas le nombre de points d'arrêt plus un point pour la base.
							@ Le nombre de véhicule: dans notre cas 1 car nous routons chaque chargeur un par un.
							@ L'index du point de dépôt: dans notre cas la base.
						\end{easylist}
						
						Les lignes 8 et 9 permettent de définir les distances entre les différents points et l'assigner à notre model.
						La classe \klass{DistanceCallBack} contient notamment une méthode qui à partir de deux indices de points va renvoyer une distance.
						Il est à noter que dans la librairie cette distance est un entier, or notre programme utilise des nombres réels.
						Cela a pour conséquence de perdre des informations.
						Par exemple si nous prenons un carré de coté 1 entre 4 points, toutes les distances seront de 1 (même les diagonales).
						Pour effacer un peu ce problème, la distance sera multipliée par une constante << Callbacks.COST\_MULTIPLICAND >>.
						Actuellement sa valeur est 10 et nous permet donc de garder une précision d'un chiffre après la virgule.
						
						Les lignes 12 et 13 ajoutent une nouvelle dimension << time >> au problème en lui affectant \klass{TotalTimeCallback} comme source pour les valeurs.
						De manière similaire, à partir de deux indices, une valeur sera retournée.
						Sauf que cette fois-ci cette dernière représentera le temps nécessaire pour se rendre à un point et recharger ce dernier.
						
						La ligne 15 définit les paramètres de notre model.
						On définit notamment le fait que nous voulons calculer l'arc le moins cher et lui définissons un temps maximal de calcul.
						
						La ligne 21 résout notre modèle.
						
						Les lignes 22 à 28 permettent d'extraire les résultats qu'OR-Tools a trouvé.
						Ces derniers sont répartis en deux listes:
						\begin{easylist}
							@ Liste des indices des points à visiter dans l'ordre. Par exemple << $\left\{ 2,1,0 \right\}$ >> inversera l'ordre actuel de la liste dans le cas de 3 zones d'arrêt.
							@ Liste des temps d'arrivé sur chaque point définit dans la première liste.
						\end{easylist}
						
						Les deux listes sont ensuite utilisées pour réorganiser la liste dans \klass{ChargerTour}, définir les temps estimés d'arrivé à une zone et mettre à jour les fenêtre de temps interdites dans les zones en conflict.
							
					\subparagraph{TSPMTW}
						Le TSPMTW est utilisé pour les autres \klass{ChargeurTour} et est très similaire au code du TSP.
						
						Seul le code suivant est inséré à la ligne 14 du code précédent (\autoref{code:tsp}).
						
						\javasourcefile[caption=TSPMTW,label=code:tspmtw]{Code/TSPMTW.java}
						
						La ligne 2 permet d'obtenir la contrainte nommé << time >>.
						
						La ligne 4 itère pour chaque n\oe ud les opérations suivantes:
						\begin{easylist}
							@ Ligne 5 et 6: récupère la contrainte du temps pour un noeud donné.
							@ Ligne 7: définit la plage dans laquelle le noeud peut être rechargé.
							@ Ligne 8 et 9: pour chaque fenêtre de temps d'interdiction, on interdit le rechargement dans notre model.
						\end{easylist}
						
					\subparagraph{Limites}
						La résolution de ce problème est, de par sa nature, non résoluble en temps polynomiale.
						Nous avons donc des approximations de la solution optimale.
						De plus du fait des hypothèses précédentes, ce qui est calculé dans le modèle ne reflète pas à 100\% ce qu'il se passera dans la simulation.
			
			\subsubsection{Evènements}
				La partie théorique étant résolue et ayant notre tournée de prête, il nous reste plus qu'à la jouer dans la simulation.
				Pour cela des évènements supplémentaires ont été créés.
				Nous ne décrirons cependant pas les évènements de métrique (chaque évènement déclenche un évènement de métrique associé).
				
				Le point de départ est \klass{TourStartEvent} créé par le routeur et permet le début de la tournée.
				Ce dernier va créer des évènements \klass{TourTravelEvent} pour chaque chargeur qui va représenter le trajet de la position actuel au point à charger.
				
				\klass{TourTravelEvent} a deux cas possibles:
				\begin{easylist}
					@ Si plus aucun point n'est à charger, un évènement \klass{TourEndEvent} est généré à $t+t_b$ où $t_b$ est le temps de trajet pour retourner à la base.
					@ Sinon un évènement \klass{TourChargeEvent} est généré à $t+t_b$ où $t_b$ est le temps de trajet pour aller au point.
				\end{easylist}
				
				\klass{TourChargeEvent} a deux cas possibles lui aussi:
				\begin{easylist}
					@ Si le point à charger est actuellement en conflict, le chargement sera réessayé à $t+1$.
					@ Sinon on recharge le point. Un évènement \klass{TourTravelEvent} est créé à $t+t_c$ où $t_c$ représente le temps de recharge de la zone. Il est à noter que le temps de charge est recalculé en fonction de l'état actuel des capteurs et du chargeur utilisé. Cela permet de jouer une simulation réaliste en gommant les approximations faites lors du calcul des TSPs ou TSPMTWs. Cependant cela implique un fort décalage entre réalité et théorie. Cela à pour implication que certains points peuvent introduire de fort temps d'attente qui n'étaient pas prévus à l'avance.
				\end{easylist}
				
		\subsection{Ajout d'améliorations}
			le but de ce PRD étant de proposer des améliorations, une nouvelle classe a été crée pour cela:
			 \klass{RaultRouterModified}.
			 Cette dernière effectue les mêmes opérations que \klass{RaultRouter} mais essaie de prendre en compte une approche où les capteurs sont chargés en plusieurs phases.
			 Cependant du fait que notre modèle OR-Tools est assez simplisme nous effectuons encore des hypothèses.
			 En effet nous ne savons pas si le chargeur fera 3 puis 2 ou bien 2 puis 3.
			 Cela pourrait avoir une influence sur la répartition des temps de recharge, et donc sur les fenêtres de temps interdites.
			 A cause de cela nous imposons à l'avance le temps de recharge de chaque zone de manière aléatoire.
			 \textbf{Il se peut donc que lors de la simulation l'ordre soit inversé et donc des temps d'attente non prévus soient ajoutés}.
			 
			 Le reste des améliorations proposés peuvent s'effectuer principalement dans le fichier de configuration JSON en modifiant les paramètres de $L_r$ ou $L_c$.
			
		\subsection{Interface graphique}
			A ce point la simulation est jouée dans la console.
			Cela est suffisant afin obtenir des résultats mais assez peu pratique pour se rendre compte de ce qu'il se passe dans la simulation.
			
			Pour cela nous proposons une interface graphique qui va afficher différentes représentations de l'état actuel de la simulation.
			Cette dernière se présente principalement comme listener des évènements de métrique et agit donc vraiment comme une vue sur l'état et non pas comme un moyen d'interagir avec cette dernière.
			De ce fait nous avons un modèle MVC est simplifié où le contrôleur est très réduit.
			De plus, l'utilisation de JavaFX permet d'automatiser beaucoup d'actualisations des éléments graphiques.
			
			\subsubsection{Contrôles de la simulation}
				Comme dit précédemment le but de la vue n'est pas d'avoir un contrôle sur la simulation.
				Cependant certains moyens d'interagir sont quand même disponible.
				
				\img{uiControls.png}{Boutons de contrôle de la simulation}{}
				
				Nous y retrouvons deux boutons afin de mettre en pause ou reprendre la simulation.
				Ces derniers vont modifier une variable dans le \klass{Simulator}.
				
				Nous pouvons aussi observer le temps actuel de la simulation.
				Cette dernière est mise à jour automatiquement par JavaFX.
				En effet ce dernier est stocké dans une Property, élément de JavaFX qui implémente un pattern Observer.
				Cela a donc pour conséquence de mettre à jour chaque élément graphique reposant sur cette variable.
				
				Enfin un slider est présent et permet d'ajuster la vitesse de la simulation.
				Ce ressenti est réalisé en ajoutant un temps de pause entre chaque itération du simulateur.
				Le slider influe sur ce temps de pause.
				Encore une fois cela est fait avec une Property, dès que le slider change, la variable associée est modifiée automatiquement.
			
			\subsubsection{Etat des batteries}
				La première visualisation qui a été implémenté consiste à afficher les différentes capacité des chargeurs au cours du temps.
				Le moyen le plus simple de réaliser cela est sous forme d'un graphique avec en abscisse le temps et en ordonnée la capacité.
				
				Cette représentation est très simpliste mais ne permet pas de tout voir.
				En effet on peut repérer les moments de recharge mais rien de plus.
				De plus avec un grand nombre de capteurs le graphique devient assez vite illisible.

				Contrairement à la vue précédente, ici nous ne faisons que lire les données du simulateur.
				Pour cela le graphique implémente simplement \klass{MetricEventListener} et construit sa fenêtre basé sur les évènements de métrique.
				
				\img{uiCapacity.png}{Visualisation de la capacité des capteurs}{}
							
			\subsubsection{Carte des éléments}
				\img{uiMap.png}{Visualisation de la simulation sous forme spatiale}{}
				
				Une autre approche implémentée est de visualiser la simulation sous forme spatiale en plaçant les différents éléments sur une << carte >> et les faire évoluer au cours du temps.
				Cette approche permet de visualiser plus simplement ce qu'il se passe dans la simulation mais a le désavantage de ne pas conserver cette évolution (on ne peut pas revenir en arrière dans le temps).
				
				Ici nous représentons uniquement les capteurs et chargeurs ainsi que quelques informations visuelles.
				Les carrés représentent les capteurs.
				Ces derniers peuvent voir plusieurs états:
				\begin{easylist}
					@ Vert: Le capteur est dans un état normal (capacité au dessus de $L_r$).
					@ Orange: Le capteur a sa capacité en dessous de $L_r$ et a effectué une requête.
					@ Rouge: Le capteur est en dessous de $L_c$ et a effectué une requête.
				\end{easylist}
				
				On a plus de détail précis sur la capacité de ces derniers mais avons tout de même une indication sur les étapes majeures de l'évolution de la batterie.
				
				Vient ensuite les chargeurs.
				Ils sont représentés par des disques avec un cercle autour d'eux représentant leur rayon d'action.
				De la même manière plusieurs états sont possibles:
				\begin{easylist}
					@ Cyan: Le chargeur est au repos ou en attente à cause d'une zone en conflict.
					@ Violet: Le chargeur est en cours de déplacement vers l'emplacement où il se trouve.
					@ Rose: Il est en train de recharger des capteurs dans son rayon d'action. A ce moment des petites flèches supplémentaires rose vont apparaître montrant plus précisément quels capteurs sont rechargés.
				\end{easylist}
				
				En plus de ces éléments, nous retrouvons une croix épaisse au centre de la zone dénotant les coordonnées $\left( 0;0\right)$ étant la base des chargeurs.
				On y observe aussi des flèches plus minces permettant de visualiser le trajet que chaque chargeur va réaliser pour effectuer une tournée.
				
				Cette vue est particulièrement efficace pour repérer les interactions entre les chargeurs et entre les chargeurs et capteurs.
				On y identifie rapidement les moments où des chargeurs sont en conflicts.
				
				Afin de faciliter la navigation dans cette vue, il est possible de déplacer la zone en restant cliqué dans celle-ci et glissant la souris.
				Nous pouvons aussi zoomer grâce à la molette.
				
				A titre indicatif pour montrer que les évènements de métriques permettent un identification poussée de la scène, la vue repose totalement sur les évènements suivants: \klass{LrRequestMetricEvent}, \klass{LcRequestMetricEvent}, \klass{SensorChargedMetricEvent}, \klass{TourStartMetricEvent}, \klass{TourTravelMetricEvent}, \klass{TourTravelBaseMetricEvent}, \klass{TourTravelEndMetricEvent}, \klass{TourEndMetricEvent}, \klass{TourChargeMetricEvent} et \klass{TourChargeEndMetricEvent}.
	
	\section{Analyse des résultats}
		Afin de savoir si l'ajout de nos modifications dans l'algorithme a une pertinence, nous allons tester les deux versions grâce au simulateur.
		L'instance utilisée va essayer de se rapprocher le plus possible de ceux utilisés dans le papier de Mme Rault:
		\jsonsourcefile[caption="Lr=3 / Lc=18 / sensors=50 / chargers=5"]{../Simulator/instances/3-18-50-5.json}
		
		Cette configuration a été utilisée pour réaliser 100 réplications.
		Vous trouverez ci-dessous des histogrammes montrant la répartition de la différence entre les deux méthodes sur trois critères:
		\begin{easylist}
			@ Le temps de panne des capteurs.
			@ Le temps d'inactivité des chargeurs.
			@ La capacité utilisé par les chargeurs.
		\end{easylist}
		
		\img{result-deplet-3-18-50-5.png}{Différence du temps de panne entre les deux méthodes (les scores positifs sont meilleurs)}{}
		Nous pouvons observer que dans la majorité des simulations le temps de panne est légèrement détérioré.
		Cependant cela est aussi contrasté par certaines simulations où ce dernier est soit très diminué, soit très augmenté.
		
		\img{result-inact-3-18-50-5.png}{Différence du temps d'inactivité des chargeurs entre les deux méthodes (les scores positifs sont meilleurs)}{}
		En revanche le temps d'inactivité des chargeurs voit un gain important.
		Une amélioration faible dans la majorité des cas, mais qui s'étendent aussi à des valeurs plus grandes dans certains cas.
		Dans aucune simulation il a été détérioré.
		
		\img{result-used-3-18-50-5.png}{Différence du temps d'inactivité des chargeurs entre les deux méthodes (les scores positifs sont meilleurs)}{}
		Concernant La capacité utilisée cela reste assez stable même si on a une majorité des cas où un peu plus est utilisé.
		Cependant on observe un minorité où cette dernière est grandement moins utilisé.
		
		Il faut aussi noter que la majorité des cas représente une différence très minime puisque les valeurs varient autours de 22000 (un changement de 500 représente 2\%).
		
		Voici dans le tableau ci-dessous un résumé des moyennes et écart-types de ces différences.
		On remarque notamment le fait que les valeurs sont très étalées grâce à l'écart-type très fort.
		\begin{tabularx}{\textwidth}{|c|X|X|X|}
			\hline
			& Temps de panne & Temps d'inactivité & Capacité utilisé\\\hline
			Moyenne & -17 & 186.378 & 196.853\\\hline
			Ecart-type & 344.465 & 597.892 & 784.709\\\hline
		\end{tabularx}
		
		De manière générale on semble observer que la version modifiée dégrade légèrement les performances (temps de panne \& capacité utilisée) mais diminue le temps d'inactivité.
		Il est nécessaire de garder en tête le fait que le simulateur est loin d'être parfait.
		En effet toutes les approximations faites durant la phase de résolution du problème entrainent de forts décalages avec ce qu'il se passe dans la simulation.
		Cela peut notamment entrainer de nombreux conflicts entre les chargeurs et donc décaler tous les temps prévus de recharge ayant ainsi un impact sur le temps de panne des capteurs qui doivent attendre plus longtemps que prévu.
		
		\subsection{Autres résultats}
			Etant donné que les résultats sont très liés aux instances utilisées, nous allons essayer d'étudier l'impact des différents paramètres sur les résultats.
			Pour cela nous allons faire varier un paramètre à chaque fois et comparer la moyenne des réplications (50) entre la version normale et version modifiée pour chaque métrique.
			
			\subsubsection{Nombre de capteurs}
				Ici nous gardons la zone de capteurs comme étant fixe ($25m^2$) mais changeons le nombre de ces derniers.
				
				\img{evol-sensors.png}{Evolution en fonction du nombre de capteurs (bleu: panne, orange: inactivité, gris: capacité utilisé)}{}
				
				Le même phénomène semble se généraliser.
				Le temps de panne n'est pas amélioré mais la capacité utilisé et l'inactivité des chargeurs l'est.
				
			\subsubsection{Nombre de chargeurs}
				Comme la simulation précédente, nous gardons les même paramètres, avec un nombre fixe de capteurs de 100 et un nombre variable de chargeurs.
				
				\img{evol-chargers.png}{Evolution en fonction du nombre de chargeurs (bleu: panne, orange: inactivité, gris: capacité utilisé)}{}
				
				Encore une fois nous observons la même chose.
				
	\section{Conclusion}
		Après les différents tests effectués, assez peu variés par manque de temps, nous pouvons conclure que la méthode proposée n'améliore pas les performances de l'algorithme en général.
		Certes certaines métriques semblent être améliorées comme le temps d'inactivité ou la capacité utilisé, cependant la métrique principale, le temps de panne, est détériorée.
		
		Cela est cependant à mettre en parallèle avec la fiabilité du simulateur.
		En effet comme mentionné précédemment 
			 un décalage non négligeable entre les résultats d'OR-Tools et la simulation est présent.
		De plus la librairie ne donne parfois pas de solutions et donc l'algorithme n'est pas appliqué correctement.
		
		Il serait intéressant de réitérer les simulations une fois que les points cités précédemment soient corrigés.
		Il est de mon point de vue fort possible d'obtenir des résultats positifs si le décalage est moins important et donc que les interférences entre chargeurs soient réduits.
	
\chapter{Bilan et conclusion}
	Ce Projet de Recherche et Développement se découpe en deux étapes majeures (S9 et S10).
	La première est principalement axée sur l'analyse de tout l'écosystème du projet ainsi que la définition du cahier de spécification.
	La seconde en revanche consiste en le développement de la solution imaginée et l'analyse des résultats obtenus.
	
	\section{Bilan S9}
		Nous allons ici exposer les différentes tâches qui ont été réalisés lors du S9 ainsi que celles qui sont en retard.
		Nous terminerons ensuite cette partie par un premier aperçu des tâches qu'il reste à faire.
		
		\subsection{Réalisation}
			\subsubsection{Recherche -- Spécifications}
				\begin{easylist}[itemize]
					@ Compréhension du sujet.
					@ Analyse de la solution proposée ainsi que des papiers liés.
					@ Identification des améliorations possibles.
					@ Modélisation algorithmique.
					@ Écriture des spécifications.
					@ Écriture du rapport du S9 \& préparation de la soutenance.
					@ Réalisation d'un diagramme de classe global pour le simulateur.
				\end{easylist}

			\subsection{Développement}
				\begin{easylist}[itemize]
					@ Codage d'un parser de configuration.
					@ Ajout de tests pour le parser.
					@ Codage du simulateur à son niveau le plus bas.
					@ Ajout de classes/évènements pour modéliser la solution de Mme Rault.
					@ Début d'ajout de la collecte de métriques.
				\end{easylist}

		\subsection{En retard}
			Aucun retard sur les tâches n'est encore survenu.
			En réalité il y a plutôt une avance dans la réalisation du projet avec la partie codage du simulateur qui est actuellement à un stage déjà quasi fonctionnel.
			
		\subsection{Planification S10}
			Le déroulé du S10 repose principalement sur la réalisation du simulateur ainsi que l'étude des résultats obtenus.
			
			Pour cela il sera nécessaire de faire les tâches suivantes:
			\begin{easylist}[itemize]
				@ Finalisation du simulateur:
				@@ Compléter l'implémentation de la solution de Mme Rault:
				@@@ Ajout des calculs des \glspl{tspmtw}.
				@@@ Ajout de l'algorithme calculant les points d'arrêts.
				@@ Capturer plus de métriques.
				@@ Exportation des résultats sous forme graphique.
				@@ Implémentation des amélioration proposées.
				@@ Ajout de tests au simulateur.
				@ Création des jeux de données pour le simulateur.
				@ Analyse des résultats
				@ Rédaction du rapport du S10.
			\end{easylist}
		
	\section{Bilan S10}
		Nous allons ici exposer les différentes tâches qui ont été réalisés lors du S10 ainsi que celles qui reste à faire ou les potentielles améliorations envisageable.
		
		\subsection{Avancée}
			\begin{easylist}[itemize]
				@ Finalisation du simulateur:
				@@ Algorithme de Mme Rault.
				@@ TSP.
				@@ TSPMTW.
				@ Extraction de métriques.
				@ Analyse des résultats
			\end{easylist}
		
			Grâce au simulateur il a été possible d'extraire des résultats afin d'y effectuer des analyses.
			L'objectif principal du PRD est donc atteint.
			Cependant la solution proposée n'est pas parfaite et les résultats obtenus peuvent encore beaucoup changer avec l'avancée du simulateur.
		
		\subsection{Améliorations envisageables}
			\begin{easylist}
				@ Amélioration de l'utilisation d'OR-Tools:
				@@ Modification du code pour que la librairie renvoie une solution plus souvent.
				@@ Mise à jour de la librairie pour éviter des crash de la JVM.
				@ Amélioration de la méthode de clustering des capteurs à recharger.
				@ Ajout de nouvelles visualisations dans l'UI afin de suivre plus facilement le déroulement de la simulation et repérer de potentiels problèmes.
			\end{easylist}
			
		\subsection{Bilan qualité}
			La qualité de la base du simulateur semble solide.
			En effet il est très modulable et peut être étendu très facilement pour y implémenter un nouvel algorithme ou éléments.
			Les différents documents en annexes devraient faciliter la prise en main du code afin que ce dernier puisse être repris de manière efficace.
			
			Concernant l'implémentation de l'algorithme de routage il est à revoir.
			En effet de nombreux points remettent en cause les résultats finaux car la simulation n'est pas fidèle à la théorie.
			Cela passe par la phase de clustering qui est très différente et OR-Tools donnant des solutions pas toujours proche de la simulation.
			
			Enfin de manière générale le code comprends des tests unitaires qui sont joués automatiquement en intégration continue.
			Cela aide grandement à maintenir un code valide.
			Cependant la couverture de ces derniers n'est que de 30\%.
			Bien que tester le simulateur en lui-même est difficile, il est possible d'étendre cette couverture en testant plus profondément le modèle représentant nos éléments de la simulation.
			Le simulateur pourrait être testé avec des tests d'intégrations avec \href{https://cucumber.io/}{Cucumber par exemple}.
		
		\subsection{Bilan auto-critique}
			Le PRD a été une bonne occasion de mettre en \oe uvre les différentes compétences que nous avons apprises tout au long de notre formation.
			Le fait d'être en solitaire sur le projet nous pousse vraiment à réfléchir par nous-même et nous permet de nous rendre compte de nos acquis dans un environnement mélangeant plusieurs disciplines.
			
			Je pense que mon projet s'est bien passé.
			Une grande autonomie m'a permis d'avancer malgré un premier semestre où les rencontres étaient difficiles.
			Cependant il aurait peut-être été meilleur si j'aurai fait preuve d'un peu plus d'initiatives pour aller à la rencontre de l'encadrant.
			
			Les résultats sur l'avancé du projet ont toujours étés positifs.
			Certains problèmes sont survenus mais des alternatives ont étés trouvées.
			
			De plus ce projet a été l'occasion pour moi de mettre en place de l'intégration continue avec Gitlab ainsi que d'autres outils pour garder un \oe uil sur la qualité du code (jacoco, pmd).
			
	
\appendix
\chapter{Découverte du sujet}
	\img[changes]{changes.png}{Première compréhension du sujet}{}
	
\chapter{Planification\label{sec:plannification}}
	Toute la planification du projet va se faire au travers d'un système de cartes pouvant se retrouver dans 3 états différents:
	\begin{easylist}
		@ Non commencée
		@ En cours
		@ Terminée	
	\end{easylist}
	
	Ce procédé peut sembler très différent de l'utilisation d'un diagramme de Gantt mais est en faite assez similaire si l'on oubli la partie présentation.
	En effet, on découpe notre projet en une suite de tâches qui devront être réalisées dans un ordre donné. Chacune d'entre elles va comporter une date de fin qui sera à respecter et peut éventuellement contenir des sous-tâches plus précises.
	
	Toutes ces tâches peuvent elles-même être regroupées dans une << milestone >> permettant d'avoir une vue plus globale sur les tâches à réaliser pour une partie donnée.
	
	Ce choix me parait être intéressant car on retrouve toujours la notion du temps tout comme dans un Gantt mais il est plus facile d'insérer de nouvelles tâches au besoin du fait que ce système met l'accent sur les dates de fin au lieu de dates de début et fin.
	De plus de tels outils s'intègrent parfaitement dans les outils VCS modernes tels que GitLab ou GitHub.
	
	Nous allons donc détailler l'outil qui a été utilisé (GitLab) puis décrire les différentes tâches identifiées.

	\section{Outils\label{sec:issues}}
		Commençons tout d'abord par présenter le système de cartes qui a été utilisé.
		Ce dernier est proposé par GitLab, un site web mettant à disposition des dépôts Git permettant de versionner son code pour garder les traces de toutes modifications.
		
		Le plus souvent ces entreprises mettent aussi à disposition un système de gestion de << tickets >>.
		
		\img{Issue.png}{Exemple d'une issue}{}
		
		Un ticket représente une tâche à effectuer et comporte plusieurs éléments la définissant:
		\begin{easylist}
			@ Titre.
			@ Description: Permet de décrire plus précisément ce qui est attendu.
			@ Assignee: La personne assignée sur la tâche. Dans notre cas cela n'a pas trop de sens puisque je suis tout seul mais nous utiliserons ce système pour différencier une tâche non commencée (non assignée) d'une tâche en cours (assignée).
			@ Milestone: Représente l'étape du projet qui englobe la tâche. Nous verrons par la suite le tableau de gestion des tâches par milestone.
			@ Time tracking: Permet d'indiquer le temps que l'on a passé sur une tâche. Cela peut être utile pour estimer les prochaines tâches ou tout simplement vérifier que le temps passé sur une tâche ne devient pas excessif.
			@ Due date: La date due.
			@ Label: Représente une liste de labels que l'on peut appliquer afin de catégoriser la tâche.
		\end{easylist}
		
		De cette manière on peut organiser nos tâches tout en laissant une flexibilité sur l'ordre dans lesquels elles sont réalisées (sauf si une tâche en requiert une autre), du temps que les tâches sont réalisées avant la date de fin.
		
		De plus le regroupement de nos tâches en milestones nous permet d'avoir une vue plus focalisé sur le travail que nous avons à faire à un moment donné.
		La vue ressemble à l'image ci-dessous:
		\img{Milestone.png}{Vue milestone}{} 
		
		Comme on peut le voir, la plus grosse partie représente les différentes tâches d'une étape. Cela est très pratique pour avoir une vue générale de ce qu'il reste à faire.
	
	\section{Découpage des tâches}
		\subsection{Gestion de projet et version}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de déterminer la méthode et les outils qui seront utilisés pour la gestion de projet.
				@ \textbf{Estimation de charge}:
				
				1 jour/homme.
			\end{easylist}
			
		\subsection{Compréhension des objectifs et du contexte}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de prendre en main le sujet en découvrant le papier déjà réalisé et prendre connaissance des objectifs.
				@ \textbf{Estimation de charge}:
				
				2 jour/homme.
			\end{easylist}
			
		\subsection{Rédaction du cahier de spécification}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rédiger la partie spécification du rapport. Ce dernier sera amélioré au cours du projet.
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Etudier l’existant}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rentrer plus en détail dans le papier de Mme Rault tout en analysant les ressources utilisées afin d'envisager des premières pistes d'amélioration.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
			\end{easylist}
			
		\subsection{Etat de l'art}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rédiger l'état de l'art afin de rendre compte des méthodes utilisés dans le papier.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
			\end{easylist}
			
		\subsection{Analyse des améliorations}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de présenter une analyse des améliorations possibles de l'algorithme de génération des tournées.
				@ \textbf{Estimation de charge}:
				
				5 jour/homme.
			\end{easylist}
			
		\subsection{Analyse du simulateur}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de présenter une première analyse de la conception du simulateur.
				@ \textbf{Estimation de charge}:
				
				5 jour/homme.
			\end{easylist}
			
		\subsection{Finalisation du rapport S9}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de finaliser le rapport pour le S9.
				@ \textbf{Estimation de charge}:
				
				2 jour/homme.
				@ \textbf{Livrable}:
				
				Rapport final du S9.
				@ \textbf{Date limite}:
				
				10/12/2018
			\end{easylist}
			
		\subsection{Préparation de la soutenance S9}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de préparer la soutenance du S9.
				@ \textbf{Estimation de charge}:
				
				2 jour/homme.
				@ \textbf{Livrable}:
				
				Exposé PowerPoint.
				@ \textbf{Date limite}:
				
				12/12/2018
			\end{easylist}
			
		\subsection{Réalisation du simulateur}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de réaliser le simulateur.
				Elle sera effectuée en plusieurs sprints.
				@ \textbf{Estimation de charge}:
				
				16 jour/homme.
				@ \textbf{Livrable}:
				
				Plusieurs versions de l'application.
			\end{easylist}
			
		\subsection{Expérimentation des solutions proposées}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de réaliser les tests sur les améliorations proposées précédemment.			
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Interprétation des résultats expérimentaux}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but d'analyser les résultats obtenus et les mettre en parallèle avec la solution d'origine.			
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Questionnaire gestion de projet}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Fournir les documents pour l'évaluation de la gestion de projet.			
				@ \textbf{Estimation de charge}:
				
				0.5 jour/homme.
				@ \textbf{Livrable}:
				
				Questionnaire gestion de projet.
				@ \textbf{Date limite}:
				
				27/03/2018
			\end{easylist}
			
		\subsection{Finalisation du rapport S10}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de finaliser le rapport du S10.			
				@ \textbf{Estimation de charge}:
				
				6 jour/homme.
				@ \textbf{Livrable}:
				
				Rapport final du S10.
				
				Poster du projet.
				@ \textbf{Date limite}:
				
				04/04/2018
			\end{easylist}
			
		\subsection{Préparation de la soutenance du S10}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de préparer la soutenance du S10.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
				@ \textbf{Livrable}:
				
				Exposé PowerPoint.
				@ \textbf{Date limite}:
				
				27/04/2019
			\end{easylist}
	\section{Gantt}
		Si l'on essaie de représenter les tâches du S9 dans un Gantt, on obtient un diagramme théorique suivant:
		\img{gantt.png}{Diagramme de Gantt}{}

\chapter{Spécifications fonctionnelles}
	Nous allons dans cette partie introduire les fonctions principales qui peuvent être utilisées dans le simulateur.
	
	\section{Importation des paramètres}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet de lire le fichier d'entrée contenant les paramètres de la simulation.
			@ \textbf{Présentation}:
			
			- Nom: SimulationParameters.fromJSON
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			Afin de pouvoir personnaliser la simulation on laisse l'utilisateur fournir un fichier de configuration.
			Ce dernier permet de préciser le nombre, type et comportement de différents éléments de la simulation.
			Plus de détails sur le format du fichier en \autoref{sec:jsoninput}.
			@ \textbf{Description précisée}:
			
			- Entrée: Le fichier à lire.
			
			- Sortie: Un objet SimulationParameters initialisé.
			
			- Exception: Si le fichier n'existe pas, est illisible ou contient une configuration invalide.
		\end{easylist}
		
	\section{Module de simulation}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet de lancer une simulation afin d'obtenir des métriques.
			@ \textbf{Présentation}:
			
			- Nom: Simulator.run
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			La simulation aura pour but de simuler un environnement de capteurs avec les différents chargeurs mobiles.
			Cette partie devra prendre en compte la configuration afin de lancer la simulation voulue.
			De plus les implémentations personnalisées (capteurs, chargeurs, méthode de routage) devront être prises en compte.
			
			@ \textbf{Description précisée}:
			
			- Entrée: Un objet SimulationParameters.
			
			- Sortie: $\emptyset$.
			
			- Exception: $\emptyset$.
		\end{easylist}

	\section{Visualisation des résultats}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette partie permet de générer et afficher les résultats sous forme de graphiques dans une fenêtre ou dans un fichier image.
			@ \textbf{Présentation}:
			
			- Nom: -
			
			- Priorité: Modéré
			@ \textbf{Description}:
			
			Afin de pouvoir observer les résultats on envisage d'afficher dans un premier temps d'exporter les valeurs observées dans un fichier CSV puis traiter ces données pour en obtenir des graphiques.
			@ \textbf{Description précisée}:
			
			- Entrée: Les données de la métrique enregistré.
			
			- Sortie: Un graphique / CSV.
			
			- Exception: $\emptyset$.
		\end{easylist}
		
	\section{Collecte de métriques}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet d'être à l'écoute des changements dans le système afin de pouvoir les enregistrer.
			@ \textbf{Présentation}:
			
			- Nom: MetricEventDispatcher.dispatch
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			Afin d'être flexible, on propose de faire un système d'écoute de changement des valeurs du système.
			Par la suite des listeners viendront écouter ces changement pour en tirer des interprétations ou faire de l'archivage.
			@ \textbf{Description précisée}:
			
			- Entrée: Un évènement de changement de l'état du système.
			
			- Sortie: $\emptyset$.
			
			- Exception: $\emptyset$
		\end{easylist}
	
\chapter{Diagramme de classes}
	\vspace{-50pt}
	\img[diagramclass]{diagramfull.png}{Diagramme de classes complet}{}
			
\chapter{Spécifications non fonctionnelles}
	\section{Analyse de l'algorithme}
		D'un point de vue algorithmique, des améliorations de l'algorithme écrit par Mme Rault \cite{Rault:chargers} devront être proposés et détaillés.
			
		Ces dernières seront par la suite testées avec le simulateur et conduiront à une conclusion quant à l'efficacité de ces dernières.
		
		On considérera qu'un algorithme améliore une solution si le temps de rechargement est diminuée sans altérer grandement les autres métriques.
		Cette amélioration sera à noter par instance étant donné que selon la configuration de départ, le déroulement des tournées peut grandement changer.
		
		Les instances à utiliser seront celles décrites dans le papier de Mme Rault \cite{Rault:chargers}.
		Certaines d'entre elles pourront comporter des valeurs aléatoires qui seront définies dans un intervalle.
		Dans ce cas la simulation sera jouée plusieurs fois et nous garderons la moyenne des résultats comme étant notre résultat final.

	\section{Contraintes de développement et conception}
		\begin{easylist}[itemize]
			@ Langage: Java 12+
			@ Plateformes cibles: Windows, macOSX, Linux
		\end{easylist}
		
	\section{Contraintes de fonctionnement et d'exploitation}
		\subsection{Performances}
			\begin{easylist}
				@ Du point de vue environnement, le programme doit être utilisable dans la majorité des systèmes d'exploitation.
				Grâce à la JVM cela devrait être transparent au niveau du codage.
			
				@ D'un point de vue utilisateur il faut que le programme réalise la simulation dans un temps non infini.
				Il faut donc un système permettant de limiter le nombre d'itération du programme.
				On propose une méthode les limitant dans le temps en définissant une date d'arrêt.
			\end{easylist}
			
		\subsection{Capacité}
			\begin{easylist}
				@ Afin de pouvoir obtenir une vision détaillé du processus de la simulation, on met à disposition les logs du programme au travers d'un fichier.
				Pour éviter de saturer l'espace mémoire, on limite les fichiers de logs à 10Mb et ne gardons que les 10 derniers logs.
			
				@ De plus, le grand nombre d'itérations entraine un grand nombre de données accumulées.
				Il sera donc nécessaire de ne pas tout garder en mémoire RAM afin d'éviter des dépassements.
			\end{easylist}

		\subsection{Contrôlabilité}
			\begin{easylist}
				@ La simulation doit produire les même résultats pour la même configuration.
				Dans le cas d'un algorithme incluant un choix aléatoire on proposera à l'utilisateur de configurer la graine de génération de ces nombres.
				Cela permet à l'utilisateur de reproduire une simulation et analyser les logs si les résultats paraissent aberrants.
			\end{easylist}
					
\chapter{Cahier du développeur}
	\section{Description des classes}
		Nous allons dans cette section décrire les différentes classes majeures du programme.
		Commençons tout d'abord par un diagramme représentant les liens entre-elles ainsi que leur attributs/méthodes principales.
		
		\subsection{Diagramme de classes\label{sec:classes}}
			\img[classDiagramDetailled2]{DetailledClassDiagram.png}{Diagramme de classes un peu plus détaille}{}
			
		\subsection{Packages et classes}
			Toutes les classes sont organisées sous forme de packages ayant chacun un but particulier:
			
			\paragraph{fr.mrcraftcod.simulator}
				Package principal de l'application contenant tous les autres packages ainsi que:
				\begin{easylist}
					@ \class{CLIParameters}: Définit les paramètres de la ligne de commande.
					@ \class{Environment}: Représente une instance de simulation, contenant les différents << \klass{Identifiable} >>, une instance d'un << \klass{Simulator} >> et une instance d'un Random utilisé pour les générations aléatoires de cette instance.
					@ \class{Main}: Point d'entré du programme. Charge les paramètres et démarre la simulation ou l'interface graphique.
					@ \class{SimulationParameters}: Chargeur de la configuration.
				\end{easylist}
		
			\paragraph{fr.mrcraftcod.simulator.capacity}
				Package contenant les classes chargées d'obtenir une capacité depuis le fichier de configuration.
				
				\begin{easylist}
					@ \class{AbstractCapacity}: Implémente les bases pour stocker une capacité et implémente \klass{JSONParsable}.
					@ \class{Capacity}: Hérite de \klass{AbstractCapacity} et permet d'obtenir une capacité depuis une valeur.
					@ \class{RandomCapacity}: Hérite de \klass{AbstractCapacity} et génère une capacité dans un intervalle donné.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.chargers}
				Package contenant les classes d'un chargeur.
				
				\begin{easylist}
					@ \class{Charger}: Implémente \klass{JSONParsable}, \klass{Identifiable}, \klass{Positionable} et \klass{Rechargeable} et définit un chargeur dans la simulation.
					@ \class{ChargerListener}: Listener permettant pour le moment d'écouter les changements de capacité d'un \klass{Charger}.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.exceptions}
				Package contenant les exceptions personnalisées.
				
				\begin{easylist}
					@ \class{SettingsParserException}: Exception utilisée lors des erreurs durant la lecture de la configuration.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.jfx}
				Package contenant la partie interface graphique.
				
				\begin{easylist}
					@ \class{MainApplication}: Fenêtre principale de l'UI.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.jfx.tabs}
				Contient les différents onglets de l'interface graphique.

			\paragraph{fr.mrcraftcod.simulator.jfx.utils}
				Package contenant des utilitaires liés à l'UI.
				
			\paragraph{fr.mrcraftcod.simulator.metrics}
				Package contenant toute la partie gestion des métriques.
				
				\begin{easylist}
					@ \class{IdentifiableMetricEvent}: Etend \klass{ValueMetricEvent} permettant de représenter un évènement avec une valeur tout en étant associé à une instance d'un \klass{Identifiable}.
					@ \class{MetricEvent}: Représente un évènement de métrique.
					@ \class{MetricEventDispatcher}: Classe chargée de distribuer les évènement de métrique aux différents \klass{MetricEventListener}s.
					@ \class{MetricEventListener}: Listener recevant les évènements de métrique.
					@ \class{ValueMetricEvent}: Etend \klass{MetricEvent} associant une valeur à un évènement de métrique.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.metrics.events}
				Package contenant des évènements de métriques.
				
				\begin{easylist}
					@ \class{SensorCapacityMetricEvent}: Etend \klass{IdentifiableMetricEvent} et est déclenché lorsque la capacité d'un capteur est modifiée par le simulateur.
					@ \class{SensorsCapacityMetricEvent}: Etend \klass{MetricEvent} et est déclenchée lorsque au moins une capacité d'un capteur est modifié.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.metrics.listeners}
				Package contenant des implémentations de listeners de métriques.
				
				\begin{easylist}
					@ \class{DepletionMetricEventListener}: Etend \klass{MetricEventListener} permettant d'obtenir un CSV avec pour chaque date le taux de panne cumulé par capteur depuis le début.
					@ \class{ReplicationChargerCapacityUsedMetricEventListener}: Etend \klass{MetricEventListener} permettant d'obtenir un CSV avec pour chaque réplication la capacité totale utilisée par les chargeurs.
					@ \class{ReplicationTotalChargerInactiveTimeMetricEventListener}: Etend \klass{MetricEventListener} permettant d'obtenir un CSV avec pour chaque réplication le temps d'inactivité totale des chargeurs.
					@ \class{ReplicationTotalDepletionMetricEventListener}: Etend \klass{MetricEventListener} permettant d'obtenir un CSV avec pour chaque réplication le temps totale de panne des capteurs.
					@ \class{SensorCapacityMetricEventListener}: Etend \klass{MetricEventListener} permettant d'obtenir un CSV avec pour chaque date la capacité d'un capteur.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.positions}
				Package contenant les classes définissant une position.
				
				\begin{easylist}
					@ \class{Position}: Implémente les bases pour stocker une position et calculer des distances. Implémente \klass{JSONParsable} afin permet d'obtenir une position à partir de valeurs x et y.
					@ \class{RandomPosition}: Hérite de \klass{Position} et génère une position dans des intervalles donnés.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.rault}
				Package contenant les implémentations liées au modèle proposé par Mme Rault.
				
			\paragraph{fr.mrcraftcod.simulator.rault.events}
				Package contenant les implémentations de \klass{SimulationEvent}s. 
				
			\paragraph{fr.mrcraftcod.simulator.rault.metrics.events}
				Package contenant les implémentations de \klass{MetricEvent}s. 
				
			\paragraph{fr.mrcraftcod.simulator.rault.routing}
				Package contenant le routeur.
				
				\begin{easylist}
					@ \class{ChargerTour}: Représente la tournée d'un chargeur.
					@ \class{ChargingSensor}: Représente un \klass{Sensor} qui devra être chargé en lui associant le temps de charge nécessaire.
					@ \class{ChargingStop}: Définit un point d'arrêt contenant une \klass{StopLocation} ainsi qu'une liste de temps d'indisponibilité.
					@ \class{RaultRouter}: Etend \klass{Router} et implémente l'algorithme de Mme Rault.
					@ \class{RaultRouterModified}: Etend \klass{RaultRouter} et définit un modèle où un capteur peut être chargé en plusieurs étapes.
					@ \class{StopLocation}: Définit un point d'arrêt contenant une liste de \klass{Sensor}s rechargeable depuis ce point.
				\end{easylist}
			
			\paragraph{fr.mrcraftcod.simulator.rault.sensors}
				Package contenant les implémentations des capteurs.
				
				\begin{easylist}
					@ \class{LrLcSensor}: Etend \klass{Sensor} et définit un capteur avec un système à valeurs $lr$ et $lc$.
					@ \class{LrLcSensorListener}: Etend \klass{SensorListener} et génère les évènements $lr$ et $lc$.
				\end{easylist}
			
			\paragraph{fr.mrcraftcod.simulator.rault.utils}
				Package contenant des utilitaires pour le routing.
				
				\begin{easylist}
					@ \class{TourSolver}: Définit la base d'un moyen d'ordonnancer une tournée de rechargement.
					@ \class{TSP}: Etend \klass{TourSolver} en utilisant une méthode TSP.
					@ \class{TSPMTW}: Etend \klass{TourSolver} en utilisant une méthode TSPMTW.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.rault.utils.callbacks}
				Package contenant des des NodeEvaluator2 pour les modèles d'OR-Tools.
				
				\begin{easylist}
					@ \class{Callbacks}: Définit un NodeEvaluator2 avec un poids pour les valeurs.
					@ \class{ChargingTimeCallback}: Etend \klass{Callbacks} et représente le temps de recharge.
					@ \class{DistanceCallback}: Etend \klass{Callbacks} et représente les distances entre les différents points.
					@ \class{TotalTimeCallback}: Etend \klass{Callbacks} et représente la somme de \klass{ChargingTimeCallback} et \klass{TravelTimeCallback}.
					@ \class{TravelTimeCallback}: Etend \klass{Callbacks} et représente le temps de voyage entre les différents points.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.routing}
				Package contenant les classes nécessaires à la définition de modèles de routing.
				
				\begin{easylist}
					@ \class{Router}: Implémente \klass{Identifiable} et \klass{JSONParsable}. 
					Définit les méthodes nécessaires pour que le simulateur puisse effectuer des routings.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.sensors}
				Package contenant les classes d'un capteur.
				
				\begin{easylist}
					@ \class{Sensor}: Implémente \klass{JSONParsable}, \klass{Identifiable}, \klass{Positionable} et \klass{Rechargeable} et définit un capteur dans la simulation.
					@ \class{SensorListener}: Listener permettant pour le moment d'écouter les changements de capacité d'un \klass{Sensor}.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.simulation}
				Package contenant le c\oe ur du simulateur.
				
				\begin{easylist}
					@ \class{SimulationEvent}: Représente un évènement de la simulation.
					@ \class{Simulator}: Exécute la simulation consistant en une suite de \klass{SimulationEvent} pouvant interagir avec les éléments de l'\klass{Environment}.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.simulation.events}
				Package contenant les évènements de base du simulateur.
				
				\begin{easylist}
					@ \class{DischargeSensorEvent}: Etend \klass{SimulationEvent} permettant de décharger les capteurs.
					@ \class{EndEvent}: Etend \klass{SimulationEvent} permettant de marquer la fin de la simulation et arrêter le simulateur.
					@ \class{StartEvent}: Etend \klass{SimulationEvent} permettant de marquer le début de la simulation et initialiser de potentiels paramètres.
				\end{easylist}
				
			\paragraph{fr.mrcraftcod.simulator.utils}
				Package contenant des utilitaires.
				
				\begin{easylist}
					@ \class{Identifiable}: Permet de définir un élément qui est identifiable dans la simulation.
					@ \class{JSONParsable}: Définit une classe qui à partir d'un objet JSON va instancier un objet.
					@ \class{JSONUtils}: Suite d'utilitaires pour lire un format JSON.
					@ \class{Positionable}: Définit une classe ayant une position.
					@ \class{Rechargeable}: Définit une classe pouvant être rechargé (ajouter ou retirer de la capacité).
					@ \class{UnreadableQueue}: Définit une Queue où seuls les actions d'ajout sont possibles.
				\end{easylist}
		
	\section{Description des fichiers I/O}
		\subsection{Fichiers de configuration}
			Le fichier de configuration est la seule entrée que le programme accepte en entrée.
			Tout le reste de la configuration est réalisé avec des arguments passés au programme.
			Le fichier mentionné précédemment est décrit en \autoref{sec:jsoninput} et a pour but de définir l'instance qui sera utilisée.
			
			Afin de lire ce fichier nous utilisons la classe \klass{SimulationParameters} nous renvoyant un objet de la même classe contenant un \klass{Environment} qui nous servira tout au long d'une simulation.
			
			Ce fichier a pour but d'être très extensible.
			En effet la majorité des paramètres définies référencent une classe Java (\klass{JSONParsable}) qui sera initialisée.
			Peu de modifications concernant le parser sont à prévoir, il suffit uniquement de créer les nouvelles classes voulues dans le code.
			
		\subsection{Logs}
			Les logs sont un point essentiel afin de pouvoir retracer ce qu'il s'est produit dans la simulation, surtout en cas de problèmes.
			Pour cela nous utilisons la librairie \href{https://www.slf4j.org/}{slf4j} conjointement avec \href{https://logging.apache.org/log4j/2.x/}{log4j2}.
			
			slf4j a pour but de généraliser l'utilisation de loggers en offrant un grand nombre d'interfaces.
			Parmi ces dernières on y retrouve par exemple Logger qui définit un logger avec lequel on peut effectuer des opérations comme << info >>, << warn >>, << error >>.
			
			log4j2 quant à lui propose une implémentation de ces interfaces afin d'avoir un logger fonctionnel.
			Il est configuré dans un fichier << log4j2.xml >>.
			Ce dernier définit deux sorties:
			\begin{easylist}
				@ Console: écrit dans la sortie standard.
				@ RollingFile: écrit dans un fichier
				@@ Change de fichier dès que ce dernier dépasse 10Mb.
				@@ Garde seulement les 10 derniers fichiers.
			\end{easylist}
			
			Ensuite les différents loggers sont assignés aux sorties précédemment cités avec un niveau de log minimal requis afin de filtrer les messages inutiles dans le cas d'une exécution normale.
		
		\subsection{Fichiers de résultats\label{sec:dev:metrics}}
			En plus des logs, le simulateur produit des fichiers de sorties contenant des métriques.
			Ces derniers sont organisés de na manière suivante:
			\dirtree{%
				.0 .. 
				.1 metrics. 
				.2 <Stimestamp>\DTcomment{Dossier d'un lancement du programme}. 
				.3 config.json\DTcomment{Copie de la configuration utilisée pour ce lancement}. 
				.3 <outputAll>\DTcomment{Sortie de métrique offrant une valeur par réplication}. 
				.3 <outputAll>. 
				.3 $\vdots$. 
				.3 <Rtimestamp>\DTcomment{Dossier contenant les sorties propres à une réplication}. 
				.4 <outputRepl>\DTcomment{Contient une sortie de métrique sur une réplication}. 
				.4 <outputRepl>. 
				.4 $\vdots$. 
				.3 <Rtimestamp>. 
				.3 $\vdots$. 
				.2 <Stimestamp>. 
				.2 $\vdots$. 
			}
			
	\section{Structure du projet}
		Le projet suit principalement la norme de Maven avec quelques dossiers en plus:
		\dirtree{%
			.1 .. 
			.2 libs\DTcomment{Dossier contenant la dépendance OR-Tools pour Maven (repository local)}. 
			.2 log\DTcomment{Dossier de sortie des logs}. 
			.2 metrics\DTcomment{Dossier de sortie des métriques, voir \autoref{sec:dev:metrics}}. 
			.2 native\DTcomment{Dossier contenant les dll/dylib/so pour OR-Tools}. 
			.3 <numéro de version>. 
			.4 windows. 
			.4 osx. 
			.4 linux. 
			.3 <numéro de version>. 
			.2 src\DTcomment{Sources du programme}. 
			.3 main\DTcomment{Sources de production}.
			.4 java\DTcomment{Sources java, voir \autoref{sec:classes}}. 
			.4 resources\DTcomment{Ressources pour la production (images pour l'UI, log4j, ...)}. 
			.3 test\DTcomment{Sources de test}. 
			.4 java\DTcomment{Sources java pour les tests}. 
			.4 resources\DTcomment{Ressources pour les tests (fichiers de configuration à parser}. 
			.2 target\DTcomment{Sorties de Maven (compilation, Javadoc, rapports de couverture, ...)}. 
			.2 pom.xml\DTcomment{Fichier de configuration Maven, à ouvrir avec un IDE en tant que projet}. 
		}
	
	\section{Mise à jour des dépendances}
		La plus part des dépendances sont gérées avec Maven.
		Afin de les mettre à jour il suffit de changer le numéro de version de ces dernières dans le << pom.xml >>.
		Il est aussi possible d'obtenir la liste de celles non à jour grâce à la commande << mvn versions:display-dependency-updates >>.
		
		En revanche OR-Tools n'est pas disponible sur Maven.
		Actuellement il se trouve dans une repository local (dossier libs) afin de pouvoir l'inclure avec Maven.
		Si une nouvelle version veut être déployée, il faut suivre les étapes suivantes:
		\begin{easylist}
			@ \href{https://github.com/google/or-tools/releases}{Télécharger OR-Tools} pour un OS quelconque. Le ficher est sous la forme << or-tools\_os\allowbreak \_vxxxx >>.
			@ Extraire le zip, se rendre dans le dossier << lib >> et garder de coté les deux fichiers jar (protobuf et com.google.ortools).
			@ Déplacer les fichier jar. xxxx représentera la version d'OR-Tools:
			@@ Placer le fichier protobuf.jar dans << Simulator/libs/com/google/protobuf/xxxx/protobuf\allowbreak -xxxx.jar >> et renommez-le comme dans le chemin.
			@@ Placer le fichier com.google.ortools.jar dans << Simulator/libs/com/google/protobuf/xxxx/\allowbreak ortools-xxxx.jar >> et renommez-le comme dans le chemin.
			@ La version xxxx est maintenant disponible dans le << pom.xml >>>.
		\end{easylist}
	
		\subsection{OR-Tools}
			Dans la version 6 d'OR-Tools, un problème fait que la JVM plante de manière aléatoire.
			Cela semble être du à un accès mémoire incohérent.
			Les issues suivantes peuvent être liées au problème:
			\begin{easylist}
				@ \url{https://github.com/google/or-tools/issues/686}
				@ \url{https://github.com/google/or-tools/issues/621}
				@ \url{https://github.com/google/or-tools/issues/1091}
			\end{easylist}
		
			La dernière notamment semble avoir été fixée dans la version 7.
			Il pourrai donc être intéressant d'envisager d'effectuer une migration vers cette dernière lorsqu'elle est disponible.
	
\chapter{Document d'installation du projet}
	\section{Utilisation simple}
		\subsection{Java\label{sec:install:java}}
			Afin de pouvoir utiliser l'application il est nécessaire d'avoir Java 12 ou supérieur d'installé sur l'ordinateur.
			Ce dernier peut être téléchargée ici: \href{https://jdk.java.net/}{OpenJDK downloads} (ou ici pour la version Oracle: \href{https://www.oracle.com/technetwork/java/javase/downloads/index.html}{Oracle downloads})(\href{https://adoptopenjdk.net/}{une version d'OpenJDK est distribuée par AdoptOpenJDK} et propose un installateur afin de faciliter l'intallation de Java).
			Il suffit de prendre la version adaptée à l'architecture cible et suivre les étapes d'installation (peut différer selon vos besoins, néanmoins une possibilité est expliquée \href{https://stackoverflow.com/a/52531093/3281185}{ici}).

		\subsection{ORTools}
			Un autre pré-requis est la librairie OR-Tools.
			Le téléchargement se trouve ici: \href{https://github.com/google/or-tools/releases/tag/v6.10}{OR-Tools} (dans le cas de Windows ou macOSX, les fichiers nécessaires sont déjà présents dans le dossier << native >>).
			Le fichier a télécharger est nommé << or-tools\_xxxxx\_v6.10.6025 >> où xxxx représente le système d'exploitation cible.
			Une fois l'archive téléchargée, il faut l'extraire et conserver le dossier << libs >> nous sera utile par la suite (le dossier libs correspond aussi à << native/version/os >>).

	\section{Utilisation développeur}
		Afin de pouvoir faire évoluer le code, il est nécessaire d'avoir un environnement pour coder en Java 12+.
		Pour cela la partie Java vue en \autoref{sec:install:java} doit être réalisée.
		Il faut ensuite installer l'utilitaire Maven disponible \href{https://maven.apache.org/download.cgi}{ici}.
		
		Le projet est ensuite utilisable simplement comme un projet Maven (il suffit d'ouvrir le pom.xml avec par exemple IntelliJ) ce qui doit être supporté par la majorité des IDEs.
		
		Si toutefois aucun IDE n'est utilisé, il est possible de compiler le projet avec la commande << mvn package >>.
		Suite à cela le fichier jar se trouvera au chemin suivant: target/Simulator.jar.
		La commande << mvn dependency:resolve >> permet quant à elle de télécharger les dépendances nécessaires (placées dans << \textasciitilde/.m2 >>).
 

\chapter{Document d'utilisation du projet}
	\section{Fichier de configuration\label{sec:jsoninput}}
		Le fichier d'entrée du simulateur doit être sous le format JSON.
		Nous aurons donc une structure semblable à celle-ci:
		\jsonsourcefile[caption=Fichier de configuration]{../Simulator/src/test/resources/settings/settings1.json}
		
		La racine du fichier est un objet JSON contenant plusieurs éléments:
		\begin{easylist}[itemize]
			@ \textbf{seed}: Correspond à la graine utilisée pour la génération de nombres aléatoires. Si cette dernière n'est pas précisée, une graine basée sur le temps actuel sera utilisée.
			@ \textbf{end}: La date de fin de la simulation. 
			@ \textbf{environment}: Une liste d'objets définissant les objets présents dans notre simulation. Ces derniers seront décrits plus en détail en \autoref{sec:jsonconf:env}.
			@ \textbf{metrics}: Une liste de listeners de métriques à utiliser.	
		\end{easylist}
		
		\subsection{Environment\label{sec:jsonconf:env}}
			Les objets présents dans cette liste peuvent être très variés.
			De base l'application propose quelques capteurs et quelques chargeurs mais il est aussi possible d'utiliser certains objets qui ont étés créés par la suite afin de traiter le problème avec un algorithme différent.
			Cependant tous ces objets suivent la même forme:
			\begin{easylist}[itemize]
				@ \textbf{class}: La classe de l'objet dans le code JAVA.
				@ \textbf{count}: Le nombre d'objets de ce type à créer avec les paramètres donnés (si les paramètres doivent être différents pour chaque éléments, il faut que la classe JAVA gère la génération d'un nombre aléatoire dans un intervalle (qui sera passé en paramètres) ou il faut déclarer plusieurs objets dans le JSON).	
				@ \textbf{parameters}: Les paramètres pour initialiser l'objet. Ces derniers sont différents pour chaque éléments que nous voulons utiliser (ceux fournis de base sont décris en \autoref{sec:jsonconf:params}).
			\end{easylist}

		\subsection{Paramètres\label{sec:jsonconf:params}}
			\subsubsection{Chargers}
				\paragraph{fr.mrcraftcod.simulator.chargers.Charger}
					\begin{easylist}[itemize]
						@ \textbf{radius}: Nombre réel, le rayon de rechargement du chargeur.
						@ \textbf{transmissionPower}: Nombre réel, la puissance de transmission.
						@ \textbf{maxCapacity}: Nombre réel, la capacité maximale de la batterie.
						@ \textbf{currentCapacity}: objet JSON (\autoref{sec:jsonconf:capacity}), la capacité.
						@ \textbf{speed}: La vitesse de déplacement.
					\end{easylist}
			
			\subsubsection{Capteurs}
				\paragraph{fr.mrcraftcod.simulator.sensors.Sensor\label{sec:jsonconf:sensor}}
					\begin{easylist}[itemize]
						@ \textbf{powerActivation}: Nombre réel, la puissance minimale pour activer le rechargement.
						@ \textbf{position}: objet JSON (\autoref{sec:jsonconf:pos}), la position.
						@ \textbf{maxCapacity}: Nombre réel, la capacité maximale de la batterie.
						@ \textbf{currentCapacity}: objet JSON (\autoref{sec:jsonconf:capacity}), la capacité.
						@ \textbf{dischargeSpeed}: La vitesse de déchargement.
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.rault.sensors.LrLcSensor}
					\begin{easylist}[itemize]
						@ Pareil que fr.mrcraftcod.simulator.sensors.Sensor (\autoref{sec:jsonconf:sensor}).
						@ \textbf{lc}: Nombre réel, la valeur de lc.
						@ \textbf{lr}: Nombre réel, la valeur de lr.
					\end{easylist}
					
			\subsubsection{Routing}
				\paragraph{fr.mrcraftcod.simulator.rault.routing.RaultRouter}
					\begin{easylist}[itemize]
						@ $\emptyset$
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.rault.routing.RaultRouterModified}
					\begin{easylist}[itemize]
						@ $\emptyset$
					\end{easylist}
					
			\subsubsection{Position\label{sec:jsonconf:pos}}
				\paragraph{fr.mrcraftcod.simulator.positions.Position}
					\begin{easylist}[itemize]
						@ \textbf{x}: Nombre entier, la position $x$.
						@ \textbf{y}: Nombre entier, la position $y$.
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.positions.RandomPosition}
					\begin{easylist}[itemize]
						@ \textbf{max}: Nombre entier, la borne maximum pour la génération aléatoire. Les valeurs $x$ et $y$ seront telles que $x,y\in\left[-max, max\right[$.
					\end{easylist}
			
			\subsubsection{Capacité\label{sec:jsonconf:capacity}}
				\paragraph{fr.mrcraftcod.simulator.capacity.Capacity}
					\begin{easylist}[itemize]
						@ \textbf{value}: La valeur de la capacité.
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.capacity.RandomCapacity}
					\begin{easylist}[itemize]
						@ \textbf{max}: Nombre entier, la borne maximum pour la génération aléatoire. La capacité sera telle que $capacite\in\left[0, max\right[$.
					\end{easylist}
				
	\section{Lancement}
		Afin de lancer le simulateur en lui-même, il suffit d'ouvrir un terminal et se rendre dans le dossier contenant le fichier jar et lancer ce dernier avec << java -Djava.library.path=yyyy -jar Simulator.jar -c zzzz>> où yyy est le chemin vers de dossier libs précédemment téléchargé et zzz le chemin vers le fichier de configuration (\autoref{sec:jsoninput}).
		Cette commande lancera une interface graphique avec comme instance celle définie dans le fichier zzz.
	
		Il est aussi possible de rajouter le paramètre << --cli >> afin de lancer la simulation directement dans la console sans UI.
		De plus dans le mode cli nous pouvons préciser le nombre de réplications que nous voulons effectuer. Par exemple en ajoutant << --replication 54 >> le programme réalisera 54 simulations à la suite. 
	
	\section{Interface}
		\img[ui:1]{UI1.png}{Page de démarrage de l'interface graphique}{}
		
		L'image ci-dessus montre la première vue sur laquelle l'utilisateur arrivera une fois le programme lancé.
		Nous pouvons y observer 3 parties majeures:
		\begin{easylist}
			@ La zone rouge: nous y retrouvons des onglets qui vont afficher différents éléments chacun.
			@ La zone verte: cette partie regroupe des contrôles concernant la simulation:
			@@ Bouton << Play >> pour lancer la simulation.
			@@ Bouton << Pause >> pour mettre en pause la simulation.
			@@ Une indication du temps actuel de la simulation.
			@@ Un slider permettant d'altérer la vitesse du simulateur (un délais sera ajouté à chaque étape de la simulation). Le slider totalement à gauche n'induit aucun temps de délais, cependant plus le slider est glissé vers la droite plus le délais est important.
			@ La zone rose qui contient le contenu de notre onglet.
		\end{easylist}
		
		\subsection{Onglet << Sensors capacity >>}
			L'onglet sensors capacity (voir \autoref{fig:ui:1}) a pour but d'afficher une représentation sous forme de graphique de l'évolution des différentes capacités des capteurs au cours du temps.
			Chaque capteur à sa propre ligne représentant sa capacité.
			Une légende est disponible dans la partie inférieure.
			
		\subsection{Onglet << Map >>}
			Dans cette partie de l'interface nous donnons une représentation géospatiale des différents éléments en les plaçant sur un plan.
			
			\img[ui:2]{UI2.png}{Onglet << Map >> de l'interface graphique}{}
			
			L'affichage est un peu dense mais les éléments suivants apparaissent:
			\begin{easylist}
				@ Une croix noire épaisse: le point marqué par cet croix représente le centre du plan (coordonnées $\left(0;0\right)$).
				@ Des carrés de couleur: ces éléments représentent les différents capteurs de la simulation et leur couleur un état:
				@@ Verte si la capacité est plus grande que $lr$.
				@@ Orange si la capacité est entre $lc$ et $lr$.
				@@ Rouge si la capacité est plus petite ou égale à $lc$.
				@ Des disques de couleur: chaque disque représente un chargeur. Le cercle l'entourant représente le rayon dans lequel ses ondes \gls{emr} ont un impacte. De manière similaire la couleur permet de représenter l'état du chargeur:
				@@ Bleu si le chargeur est au repos.
				@@ Violet si le chargeur est en cours de déplacement.
				@@ Rose si le chargeur est en train de charger. Dans cet état des flèches roses indiqueront quels capteurs sont en train d'être chargés.
				De plus des flèches noires indiquent quelles routes les différents chargeurs vont emprunter.
			\end{easylist}

	\section{Fichiers de sortie\label{sec:csvoutput}}
		Les fichiers de sortie se retrouvent dans le dossier << metrics >>.
		Ce dernier contiendra un dossier par lancement du programme, puis sera éventuellement lui-même composé d'un dossier par réplication.
		Les fichiers seront les sorties des différentes métriques utilisées dans le fichier de configuration.
		Ces dernières pourront êtres définies par l'utilisateur dans le code mais certaines seront fournies de base:
		\begin{easylist}[itemize]
			@ Temps total de panne des capteurs.
			@ Evolution du taux de panne.
			@ Temps total des chargeurs à être inactif à cause de contraintes.
			@ Capacité totale utilisée par les chargeurs.
			@ Evolution de la capacité des capteurs.
		\end{easylist}
		
		Ces données sont fournies sous un format CSV afin d'avoir un accès aux valeurs précises et pouvoir les exploiter dans un autre programme ou bien un tableur.

\chapter{Cahier des tests}
	Afin de valider le code il est nécessaire de mettre en place des tests.
	Ces derniers peuvent se concrétiser en plusieurs formes:
	\begin{easylist}
		@ Unitaire
		@ Fonctionnel	
	\end{easylist}

	Les tests unitaires vont permettre de tester les fondations du code en vérifiant chaque méthode de manière indépendante.
	En revanche les tests fonctionnels vont se focaliser sur une fonctionnalité en général sans se soucier de la manière dont les étapes intermédiaires sont réalisées.
	
	\section{Tests unitaires}
		Dans le cadre de ce projet les tests unitaires vont se focaliser sur la partie modèle ainsi que sur le parser de configuration.
		En effet toute la partie simulation est compliquée à analyser de manière indépendante.
		
		Effectuer ces derniers nous permettra de valider les différents qui sont utilisés par le simulateur et ainsi être sûr que le comportement souhaité est bien celui implémenté.
		
		\newcounter{UnitTestIndex}
		\setcounter{UnitTestIndex}{0}
		\subsection{Tests du modèle}
			\begin{center}
				\centering
				\begin{tabularx}{\textwidth}{|c||l|X|c|}
					\hline
					\rowcolor{polytechlightblue}
					ID & Elément & Contenu & Statut\\\hline\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & Position & Test de la distance entre deux positions & \checkmark\\\hline
 					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & Position & Test de l'égalité entre deux positions & \checkmark\\\hline
 					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & Position & Test du constructeur ainsi que des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & RandomPosition & Test que les positions générées se trouvent bien dans l'intervalle défini & \checkmark\\\hline
				\end{tabularx}	
				\captionof{table}{Tests unitaires sur la partie modèle}
			\end{center}
		
		\subsection{Tests du parser de configuration}
			Lors d'un test de configuration, on charge une configuration prédéfinie puis vérifions que tous les éléments sont présents et qu'ils sont initialisés avec les bon paramètres.
			
			\begin{center}
				\centering
				\begin{tabularx}{\textwidth}{|c||l|X|c|}
					\hline
					\rowcolor{polytechlightblue}
					ID & Elément & Contenu & Statut\\\hline\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SimulationParameters & Test d'une configuration valide & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SimulationParameters & Test d'une deuxième configuration valide & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SimulationParameters & Test de cas où la capacité initiale est plus grande que la capacité maximale & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SimulationParameters & Test de cas où des paramètres sont manquants & \checkmark\\\hline
				\end{tabularx}	
				\captionof{table}{Tests unitaires sur la partie parsing de la configuration}
			\end{center}
			
		\subsection{Autre tests}
			\begin{center}
				\centering
				\begin{tabularx}{\textwidth}{|c||l|X|c|}
					\hline
					\rowcolor{polytechlightblue}
					ID & Elément & Contenu & Statut\\\hline\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & Router & Test d'une implémentation basique d'un router & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SensorCapacityMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SensorsCapacityMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & LcRequestMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & LrRequestMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & SensorChargedMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourChargeEndMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourChargeMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourEndMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourStartMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourTravelBaseMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourTravelEndMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
					\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & TourTravelMetricEvent & Test des différents constructeurs et vérification des getters associés & \checkmark\\\hline
				\end{tabularx}	
				\captionof{table}{Tests unitaires sur d'autre éléments}
			\end{center}
			
	\section{Tests fonctionnels}
		Tester la partie simulateur avec une approche unitaire est très difficile puisque cela implique de l'aléatoire et des processus non indépendants.
		Pour cela une approche plus fonctionnelle et manuelle a été entreprise.
		Un jeu d'instances a été réalisé et permet de vérifier visuellement que le simulateur effectue les actions théoriques.
		
		\begin{center}
			\centering
			\begin{tabularx}{\textwidth}{|c||l|X|c|}
				\hline
				\rowcolor{polytechlightblue}
				ID & Nom d'instance & Contenu & Statut\\\hline\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test1.json & 1 capteur \& 1 chargeurs permettant de vérifier le fonctionnement de base tels que les déplacements, déchargements & \checkmark\\\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test2.json & 1 capteur avec valeur initiale de la capacité en dessous de lr \& 1 chargeurs permettant de vérifier que le statut $lr$ est quand même déclenché & \checkmark\\\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test3.json & 1 capteur avec valeur initiale de la capacité en dessous de lc \& 1 chargeurs permettant de vérifier que le statut $lc$ est quand même déclenché & \checkmark\\\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test4.json & 1 capteur \& 5 chargeurs permettant de vérifier que plusieurs chargeurs sont routés correctement sans  conflit & \checkmark\\\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test5.json & 5 capteurs \& 1 chargeur permettant de vérifier que le routage de plusieurs capteurs est bien effectué & \checkmark\\\hline
				\stepcounter{UnitTestIndex}\arabic{UnitTestIndex} & test6.json & 5 capteurs \& 5 chargeurs permettant de vérifier que plusieurs chargeurs sont routés correctement avec plusieurs chargeurs sans conflit & \checkmark\\\hline
			\end{tabularx}	
			\captionof{table}{Tests fonctionnels}
		\end{center}
		
		\subsection{Instances des tests fonctionnels}
			\jsonsourcefile[caption=test1.json]{../Simulator/integration/test1.json}
			\jsonsourcefile[caption=test2.json]{../Simulator/integration/test2.json}
			\jsonsourcefile[caption=test3.json]{../Simulator/integration/test3.json}
			\jsonsourcefile[caption=test4.json]{../Simulator/integration/test4.json}
			\jsonsourcefile[caption=test5.json]{../Simulator/integration/test5.json}
			\jsonsourcefile[caption=test6.json]{../Simulator/integration/test6.json}

\chapter{Intégration continue\label{sec:ci}}
	Afin d'améliorer le développement, un système d'intégration continue a été mis en place.
	Cela permet d'effectuer certaines actions lorsqu'une modification sur le code est envoyé sur le serveur Git.
	Nous pouvons entre autres faire de la vérification de code grâce à une compilation et des tests.
	
	Voici les différentes étapes qui sont réalisées dans ce projet sont les suivantes:
	\img{ci-stages.png}{Etapes du CI}{}
	
	Afin de passer à une étape suivante, toutes les tâches de l'étape doivent être validées.
		
	\begin{easylist}
		@ Etape build:
		@@ Effectue la compilation du projet
		@ Etape test:
		@@ Effectue les tests unitaires du projet
		@ Etape prepare:
		@@ build-jar: Construit un jar exécutable du projet
		@@ javadoc: Génère la Javadoc du projet
		@ deploy:
		@@ Déploie les différents éléments sur une page web (Javadoc, résultats des tests de couverture)
	\end{easylist}
	
	Si nous prenons l'exemple de la Javadoc, après la fin du job concerné, il est possible de télécharger cette dernière pour le code à cet instant t:
	\img{ci-artifacts.png}{Téléchargements des fichiers du job}{scale=1}
	
	De plus les tests unitaires produisent un résultat de test de couverture permettant ainsi de se rendre compte de l'efficacité de ces derniers. 
	\img{ci-coverage.png}{Pourcentage de couverture}{}
	
	Ces résultats sont aussi disponibles sur la page principale du projet sous forme de badges.
	\img{ci-badges.png}{Page principale du projet}{}
	
	La phase de déploiement permet de mettre en ligne la Javadoc ainsi qu'une version plus poussée su rapport de couverture des tests.
	\img{jacoco.png}{Rapport JaCoCo}{}
	
\end{document}