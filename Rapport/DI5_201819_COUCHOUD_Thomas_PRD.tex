\documentclass[noposter]{polytech}

\schooldepartment{di}
\typereport{prddi5}
\reportyear{2018-2019}

\title{Amélioration d'un protocole de rechargement de capteurs}
%\subtitle{}

\student{Thomas}{Couchoud}{thomas.couchoud@etu.univ-tours.fr}
\academicsupervisor{Tifenn}{Rault}{tifenn.rault@univ-tours.fr}
\academicsupervisor{Ronan}{Bocquillon}{ronan.bocquillon@univ-tours.fr}

\addbibresource{biblio.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\resume{} %TODO
\motcle{} %TODO

\abstract{} %TODO
\keyword{} %TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newacronym{emr}{EMR}{electromagnetic radiation}
\newacronym{wet}{WET}{wireless energy transfer}
\newacronym{mc}{MC}{mobile charger}
\newacronym{tsp}{TSP}{travelling salesman problem}
\newacronym{tspmtw}{TSPMTW}{travelling salesman problem with multiple time windows}
\newacronym{ilp}{ILP}{Integer Linear Programming}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\weeklyreport{23/09/2018}{
\begin{itemize}
	\item Reception et lecture du papier de Mme Rault \cite{Rault:chargers}.
	\item Echange avec Mme Rault sur le sujet.
    \item Lecture de certaines références.
    \item Réalisation d'un petit résumé de la compréhension ainsi que des premières améliorations possibles (\autoref{fig:changes}).
\end{itemize}
}

\weeklyreport{30/09/2018}{
Avancement:
\begin{itemize}
	\item Mise en place de Biber pour le rapport.
	\item Début du rapport avec notamment la partie contexte \& état de l'art.
\end{itemize}

Questions:
\begin{itemize}
	\item Découpage des différentes parties dans le rapport étant donné qu'il est plus axé recherche.
\end{itemize}
}

\weeklyreport{07/10/2018}{
Avancement:
\begin{itemize}
	\item Ajout des parties manquantes dans l'introduction.
	\item Ecriture de la partie << Description générale >>.
	\item Début du rapport avec notamment la partie contexte \& état de l'art.
\end{itemize}

Questions:
\begin{itemize}
	\item Découpage des différentes parties dans le rapport étant donné qu'il est plus axé recherche.
\end{itemize}
}

\weeklyreport{14/10/2018}{
Avancement:
\begin{itemize}
	\item Avancement sur la partie contexte \& état de l'art.	
\end{itemize}

Questions:
\begin{itemize}
	\item Language de codage imposé?
\end{itemize}
}

\weeklyreport{21/10/2018}{
Avancement:
\begin{itemize}
	\item Finalisation contexte et état de l'art.
	\item Début d'un peu de code (parsing fichier entrée) pour se changer les idées.
	\item Rédaction des spécifications.
\end{itemize}
}

\weeklyreport{28/10/2018}{
Avancement:
\begin{itemize}
	\item Avancement sur la partie analyse.
\end{itemize}
}

\weeklyreport{11/10/2018}{
Avancement:
\begin{itemize}
	\item Ecriture de l'algorithme \autoref{alg:algorithm1}.
	\item Test de la librairie OR-Tools avec un TSP.
	\item Début d'implémentation de l'algorithme de mme Rault \cite{Rault:chargers} dans le simulateur.
\end{itemize}
}

\weeklyreport{18/10/2018}{
Avancement:
\begin{itemize}
	\item Analyse logicielle.
	\item Avancement dans le code.
\end{itemize}
}

\weeklyreport{25/10/2018}{
Avancement:
\begin{itemize}
	\item Continuation de l(implémentation de l'algorithme de mme Rault \cite{Rault:chargers} dans le simulateur.
\end{itemize}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\chapter{Introduction}
	\section{Contexte}
		Nous vivons aujourd'hui dans une société dans laquelle la collecte d'information occupe une place de plus en plus importante.
		Cette collecte peut notamment se faire par le biais de capteurs installés à différents endroits.
		
		
		Dans une quête de quantité et qualité des données, les capteurs peuvent se multiplier pour couvrir une plus grande zone et peuvent aussi se retrouver dans des environnements très différents afin d'être au plus proche de la source d'information.
		
		Cependant afin d'assurer cette adaptation à différents emplacements, les capteurs sont alimentés par le biais de batteries. 
		Ce choix technique qui induit une contrainte énergétique concernant le rechargement de ces dernières.
		Cette problématique de recharge de capteurs au sein d'un réseau a récemment gagné une attention considérable dans la communauté scientifique.
		
		En effet les technologies de transfert d'énergie sans fil (\gls{wet}) offrent de nouvelles solutions afin d'addresser le problème.
		Deux options s'offrent à nous, recharger en mode point-à-point ou point-à-multipoint.
		\begin{easylist}[itemize]
			@ \textbf{Point-à-point}: ce mode permet de charger directement un capteur en approchant le chargeur à une distance faible.
			Dans ce cas le rechargement est a son efficacité maximum.
			@ \textbf{Point-à-multipoint}: ce procédé nous autorise à charger plusieurs capteurs avec le même chargeur.
			Tous les chargeurs se trouvant dans un certain rayon autour du chargeur seront affectés.
			Cela permet des temps de chargements plus courts et moins de déplacements.
		\end{easylist}
	
		Selon les choix des outils mis en place et la politique de rechargement voulu, nous arrivons à distinguer différentes approches afin de définir le chemin que le(s) chargeur(s) devront emprunter.
		\begin{easylist}[itemize]
			@ \textbf{Rechargement périodique}: le chargeur va effectuer de manière périodique une route optimale préconfiguré.
			Certes le chemin est optimal cependant cela implique que nous connaissons à l'avance l'état du réseau de capteurs.
			@ \textbf{Rechargement à la demande}: ce procédé corrige le défaut précédent en établissant des routes à la volée.
			En effet, chaque capteur notifie dès qu'il veut être rechargé et le chemin du chargeur sera adapté à la demande.
			Cela permet ainsi de s'adapter à des réseaux plus dynamiques.
			@ \textbf{Rechargement collaboratif}: dans ce cas de figure, le but est de prendre en compte plusieurs chargeurs.
			Il est donc ici question de parralléliser les rechargements de manière efficace afin de pouvoir supporter des réseaux de plus grande taille. 
		\end{easylist}
	
		Cependant comme dit précédemment, il existe la technologie point-à-multipoint.
		Cette dernière, certes pratique, introduit une nouvelle contrainte à cause de son utilisation de radiations électromagnétiques (\gls{emr}).
		Ces rayonnements représentent un potentiel risque de santé si leur intensité dépassent un certain seuil de sécurité.
		Si une telle technologie est utilisée, notamment combiné avec le rechargement collaboratif, il est nécessaire de tenir compte de cette problématique.
		
	\section{Objectifs}
		Ce projet de fin d'études a pour but de reprendre un papier réalisé par Mme Rault \cite{Rault:chargers}, enseignant chercheur de Polytech'Tours, afin d'étudier les améliorations possibles à la solution proposée.
		Ce dernier propose une solution pour générer des tournées de \glspl{mc} de type point-à-multipoint dans un réseau de capteurs à la demande tout en tenant compte des \glspl{emr}.
		
		Cela passe par une première phase d'analyse du sujet ainsi que de la solution apportée par le papier.
		Une deuxième phase aura pour but de repérer les différents éléments pouvant améliorer l'algorithme actuel.
		
		Ces changements se concrétiserons au travers d'un simulateur qui sera pensé et réalisé afin d'exécuter différents scénarios et en obtenir des métriques sur le système.
	
	%\section{Hypothèses}
	
	\section{Bases méthodologiques}
		Afin de mener a bien le projet, différents outils vont être utilisés.
		
		\begin{easylist}
			@ La réalisation du projet se déroulera au travers d'une méthode Agile.
			En effet cette méthode permet de réaliser des << sprints >> de manière régulière dans lesquelles un livrable est réalisé à la fin.
			Ce choix permet ainsi d'avoir un retour rapide sur notre rythme d'implémentation des fonctionnalités et permet une adaptabilité plus flexible à la demande.
			De plus avoir des livrables de manière régulière me paraît important afin d'obtenir des impressions de la part des utilisateurs tout au long de la réalisation.
			
			@ Concernant la planification des tâches, cela se fera au travers d'un système de << cartes >>.
			Chaque carte contient un objectif précis ainsi qu'une date limite de réalisation.
			
			Ce choix me parait approprié car il est facile de mélanger des tâches plus théoriques avec des tâches plus pratiques.
			En effet on définit toutes les cartes (tâches) du projet dès qu'on les connait, les tâches théoriques (recherche, spécification, ...) auront une date de fin connue dès le départ tandis que les tâches techniques seront récupérées par groupes lors de la composition d'un sprint.
			Les tâches retenues pour former ce groupe dépendra ainsi des retours précédents ainsi que des priorités du client.
			
			Cette gestion et découpage est détaillé en \autoref{sec:plannification}.
			
			@ L'hébergement du code se fera sur un dépôt Git.
			Dans mon cas j'ai préféré me tourner vers \href{https://gitlab.com}{Gitlab}.
			Ce service permet de garder une trace de tout le code réalisé dans le temps.
			Cela permet notamment de pouvoir revenir en arrière si un problème majeur survient.
			
			De plus cet hébergeur met aussi à disposition un outil CI (Continuous integration).
			Si le temps me le permet il sera utile de le déployer afin d'automatiser la compilation et les tests.
			
			@ Enfin le rapport sera écrit en \LaTeX en suivant \href{https://gitlab.projectsforge.org/polytech/polytech/}{la classe plolytech}.
		\end{easylist}
			
\chapter{Description générale}
	\section{Environnement}
		La réalisation du simulateur va impliquer de coder l'algorithme détaillé dans le papier de madame Rault \cite{Rault:chargers}.
		De ce fait la résolution de \gls{tsp} et \gls{tspmtw} vont devoir être réalisés.
		Afin de ne pas perdre de temps sur la résolution de ces problèmes connus, une librairie sera utilisée.
		L'une d'entre elle est \href{https://developers.google.com/optimization/}{OR-Tools} développée par Google.
		Cette dernière est disponible dans les languages Python, C++, C\# ou bien Java ce qui permet de ne pas bloquer notre choix du language.
		
		A la vue de cette liberté et du fait que la solution sera utilisé sur une multitude de postes potentiellement très différents les uns des autres, il peut être préférable de choisir un language tel que Python ou Java afin d'améliorer la portabilité du simulateur sur différents systèmes d'exploitation.
	
	\section{Utilisateur\label{sec:users}}
		Le simulateur est réalisé à destination de chercheurs dans le domaine des capteurs sans fil.
		Même si certains d'entre eux peuvent avoir des connaissances en informatique on ne peut généraliser cela à toute la population concernée.
		Il faudra donc réaliser le programme afin qu'il soit utilisable de la manière la plus simple possible, tout en permettant aux utilisateurs un peu plus avancés de personaliser le simulateur de manière plus poussée.
		
		\begin{center}
			\centering
			\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
				\hline
				& Connaissance de l'informatique & Expérience de l'application & Type d'utilisateur & Périmètre d'action\\\hline
				Chercheur sans connaissances informatiques & Non & Non & Utilisation des fonctionnalisées basiques de manière régulière ou ponctuel & Lancer des simulations avec un algorithme donné mais possibilité de changer les paramètres de la simulation\\\hline
				Chercheur avec connaissances informatiques & Oui & Non & Utilisation complète de l'application de manière régulière ou ponctuel & Lancer des simulation avec différents paramètres et implémenter son propre algorithme de routage des différents chargeurs.\\\hline
			\end{tabularx}
			\captionof{table}{Caractéristiques utilisateurs}
		\end{center}

	
	\section{Fonctionnalités}
		Le diagramme de cas d'utilisation est disponible ci-dessous (\autoref{fig:usecase}).
		\img[usecase]{UseCase.png}{Diagramme de cas d'utilisation}{}
		
		On peut y observer les deux roles vu dans la \autoref{sec:users} ainsi que le système.
		
		Le chercheur sans connaissances informatiques va pouvoir effectuer les actions de base:
		\begin{easylist}[itemize]
			@ Modifier les paramètres de la simulation.
			On y retrouve tout ce qui touche au capteurs ainsi qu'aux chargeurs.
			En voici une liste non exhaustive:
			@@ Nombre de capteurs
			@@ Propriétés par << type >> de capteur
			@@@ Capacité maximale
			@@@ Puissance minimum de reception
			@@ Nombre de chargeurs
			@@ Propriétés par << type >> de chargeur
			@@@ Capacité
			@@@ Vitesse maximale
			@@@ Fonction de la consommation pour le trajet
			@@@ Fonction de l'efficacité du chargement
			@@@ Puissance de transmission
			@@@ Rayon d'action
			@@ Méthode de routage
			
			@ Une fois les paramètres réglés, l'utilisateur aura la possibilité de démarrer/arrêter la simulation.
			
			@ Lorsque la simulation est terminée, les différentes métriques pourront être visualisées directement dans l'interface.
			On y retrouve par exemple:
			@@ Temps de panne des n\oe uds
			@@ Temps d'attente
			@@ Energie dépensée par les chargeurs
			@@ Distance parcourue
			
			@ Enfin, afin de ne pas perdre les résultats obtenus il sera possible d'exporter les résultats (métriques obtenues).
		\end{easylist}
		
		Vient ensuite le chercheur avec les connaissances informatiques.
		Nous incluons dans cette catégorie tout ceux qui sont capables de programmer dans le language de notre application.
		Ces derniers auront les même possibilités que les chercheurs sans connaissances informatiques avec en plus:
		\begin{easylist}[itemize]
			@ Ecriture d'algorithmes de routage et enregistrement de ces derniers au près du système
		\end{easylist}
		
		Enfin le système sera chargé de gérer le déroulement de la simulation:
		\begin{easylist}[itemize]
			@ Tout commence par la lecture et interprétation de la configuration ainsi que des algorithmes de routage.
			@ En fonction de ce qui a été lu, le système exécute la simulation en tenant compte de ce qui a été défini par l'utilisateur.
			@ Enfin les données de la simulation pourront conduire à des métriques qui seront affichées dans l'interface
		\end{easylist}

			
	\section{Structure générale}
		Afin de représenter la structure interne, un diagramme de composant a été réalisé et est disponible ci-dessous.
		
		\img{componentDiagram.png}{Diagramme de composant}{}
		
		On y retrouve 5 composants principaux:
		\begin{easylist}[itemize]
			@ Chargement des données: cette partie aura pour but de lire le fichier de configuration qui est fourni par l'utilisateur afin de rendre ces données accessibles au reste du programme.
			@ Simulation: cette partie a comme objectif de gérer les différents évènements a réaliser. Cela comprend notamment de les ranger dans l'ordre de leur occurence, éventuellement priorité ainsi que générer les évènements de début/fin.
			@ Exécution/création d'évènements: dans cette partie on exécute le code associé à chaque évènement. C'est ici que des modifications sur l'état du système et génération de nouveaux évènements vont être réalisés.
			@ Enregistrement des métriques: A partir de l'exécution des métriques nous pouvons extraire des valeurs sur des métriques; cette partie à pour but d'enregistrer des dernières afin de pouvoir les synthétiser par la suite.
			@ Ecriture des résultats: lors de la fin de la simulation et avec les données des métriques enregistrées, ce composant offrira à l'utilisateur des données plus synthétisées/agrégées afin de faciliter la lecture de ces dernières. On peut par exemple construire un graphique.	
		\end{easylist}

\chapter{État de l'art}
	Nous avons évoqué en introduction que cette problématique de chargement d'un réseau de capteurs avait récemment suscité une attention particulière de la part de la communauté scientifique.
	Cela a donc mené à un certain nombre de papiers couvrant différent cas de résolution.
	Extrait du papier de Mme Rault \cite{Rault:chargers} on peut observer les différents champs couverts:
	
	\begin{center}
		\centering
		\begin{tabularx}{\textwidth}{|c||X|X|X|X|}
			\hline
			Référence & Chargement à la demande & Chargement point-à-multipoint & Chargeurs multiples & Contrainte \gls{emr}\\\hline\hline
			\cite{6275766} \cite{LIN2016381} & non & oui & non & non\\\hline
			\cite{6911792} \cite{1999253} & oui & non & non & non\\\hline
			\cite{KHELLADI201744} & oui & oui & non & non\\\hline
			\cite{LIN201688} \cite{Madhja2015} \cite{wang2013multi} \cite{Jiang2014} & oui & non & oui & non\\\hline
			\cite{7889006} & non & non & oui & non\\\hline
			\cite{NIKOLETSEAS20171} \cite{8051273} \cite{6888920} \cite{7524385} & non & oui & non & oui\\\hline\hline
			\rowcolor{polytechlightblue}
			\cite{Rault:chargers} & oui & oui & oui & oui\\\hline
		\end{tabularx}	
		\captionof{table}{Cas étudiés par d'autres papiers}
	\end{center}
	
	Beaucoup de travaux ont été réalisés sur des combinaisons de paramètres différents mais les recherches combinant tous ces derniers se font rares.
	Le papier de Mme Rault, qui est notre point de départ, propose une solution prenant en compte toutes les contraintes précédentes, c'est à dire générer des routes à la demande pour un réseau de capteurs avec plusieurs chargeurs point-à-multipoint tout en considérant la problématique des \gls{emr}.
	
	Commençons tout d'abord par expliquer la solution proposée par Mme Rault puis nous détaillerons certains éléments qui ont pu être utilisés dans ce papier.
			
	\section{Solution de Mme Rault}
		La solution proposée se découpe comme suit:
	
		\img[globalschema]{schema-global.png}{Enchainement des étapes de la solution}{}
	
		Le point de départ se situe en haut à gauche avec nos différents capteurs.
		La première étape est de proposer un service de chargement à la demande.
		Il est donc nécessaire de collecter des demandes provenant des capteurs.
		Pour cela une solution proposée par \cite{KHELLADI201744} est utilisée.
		Cette dernière repose sur un système où deux messages, $L_r$ et $L_c$, sont émis par les capteurs.
		Lorsque le niveau de batterie de ces derniers tombe en dessous un certain seuil ils envoient un signal $L_r$ au point gérant le réseau.
		Ces signaux ne sont pas alarmant et sont donc stockées jusqu'à ce qu'un signal $L_c$ d'un capteur est reçu.
		Ce dernier indiquant un niveau plus critique d'une batterie nous lançons alors la génération d'une nouvelle tournée de rechargement.
	
		La génération des routes se fait en trois étapes:
	
		\begin{easylist}[itemize]
			@ Les différents capteurs sont clusterisés, c'est à dire répartis dans plusieurs groupes, en fonction du rayon d'action $R_c$ des \gls{emr}.
			Ces derniers sont formés d'une manière à minimiser le nombre points d'arrêts que le véhicule aura a effectuer \cite{KHELLADI201744}.
			Minimiser le nombre d'arrêts nous permet de générer des clusters rechargeant le maximum de capteurs à la fois.
			
			Une fois ces points d'arrêt définis, il nous faut les affecter à l'un des chargeurs disponibles.
			Pour ce faire nous commençons par assigner un premier point de passage, tiré aléatoirement, à chaque chargeur.
			Ensuite nous sélectionnons le chargeur avec le moins de temps accumulé (somme des temps de recharge) et lui affectons le point de passage le plus proche n'étant pas déjà assigné.
			De ce fait nous minimisons le temps de voyage tout en balançant les temps de recharge entre les chargeurs.
			
			@ Maintenant que nous avons les différents points de passage pour chaque chargeur il nous faut leur donner un ordre.
			C'est ici que notre contrainte des \gls{emr} a une grande influence.
			En effect lors du calcul de ces routes nous devons nous assurer qu'il n'y ait aucun chargeur qui rentre en conflit avec un deuxième.
			
			Pour prendre cela en compte, nous introduisons la notion de points de chargements en conflits.
			Deux points $i$ et $j$ sont en conflits si $dist\left(i,j\right)<R_{c_i}+R_{c_j}$.
			Notre problème se ramène donc à calculer nos routes de manière à ce que deux points en conflit ne soient pas chargés en même temps.
			
			@@ La solution proposée consiste à calculer dans un premier temps un premier \gls{tsp} sur les points d'un premier chargeurs.
			La fonction objectif de ce \gls{tsp} est de minimiser la distance parcourue.
			
			@@ Dans un second temps nous calculons les routes des autres chargeurs séquentiellement grâce à un \gls{tspmtw}.
			Les fenêtres de temps sont calculés en retirant pour chaque zones de conflit les moments où un autre chargeur est présent.
			Ainsi pour chaque chargeur $i$ présent à un point de conflit, nous ajustons la fenêtre de temps $W_j$ par $W_j\leftarrow W_j\prive{\left[a_i-t_j, a_i+t_i\right]}$ où $a_x$ re présente la date d'arrivé du chargeur $x$ sur le point et $t_x$ le temps d'arrêt du chargeur $x$ au point.
			Le \gls{tspmtw} est ensuite lancé avec pour but de minimiser le temps de trajet.
			
			En effet il nécessaire de minimiser le temps d'attente au niveau des points de conflit.
			Si le \gls{tspmtw} à pour objectif de minimiser la distance, il est fort possible qu'un conflit apparaisse ce qui entrainera un temps d'attente.
			Il est plus profitable de parcourir un peu plus de distance et commencer à charger un cluster plutôt que d'attendre que la zone se libère.
		\end{easylist}
		
	\section{Génération des clusters\label{sec:clustering}}
		La génération des clusters est un point important dans l'algorithme.
		En effet c'est ce dernier qui va définir les points d'arrêt de nos \glspl{mc}.
		Il est donc nécessaire d'optimiser cette partie afin de ne pas se retrouver dans un cas où le chargeur recharge les capteurs un par un (la fonction du chargement point-à-multipoint serait annulée).
		
		Afin d'obtenir une solution efficace, le papier \cite{KHELLADI201744} propose de minimiser le nombre de ces points d'arrêt.
		 En effet, plus cette donnée est minimale, plus l'on a regroupé les chargeurs entre eux.
		 
		 Le problème est posé comme suit:
		 
		 Soit $\mathcal N$ l'ensemble des n\oe uds ayant effectués une requête. On pose $\abs{\mathcal N} = n$.
		 Chaque capteur $i$ dispose dispose d'un disque dans lequel le chargeur peut être placé afin de recharger ce dernier, on le note $D_i$.
		 
		 Il est a noter que dans cet algorithme on suppose que le rayon du disque de rechargement du \gls{mc} est constant.
		 
		 Afin de déterminer les points d'arrêts, il faut déterminer des intersections entre les différents disques.
		 Le problème revient donc à trouver le minimum de zones d'intersections tel que tout les disques appartiennent à l'une de ces zones.
		 
		 Ces régions $R_j$ sont définies par l'intersection de plusieurs disques $D_i$ ou bien par un disque $D_i$ lui même.
		 On obtient alors $\mathcal N_j=\bigcup_{i=1}^n\left\{i|R_j\cap D_i\neq 0\right\}$ l'ensemble des n\oe uds participant à une zone d'intersection.
		 On a aussi $\mathcal N=\bigcup_{j=1}^m\mathcal N_j$ du fait que chaque n\oe ud doit participer à une intersection.
		 
		 La résolution du problème se fait en posant deux nouvelles variables:
		 
		 $A=\left[a_{i,j}\right]$ un matrice $n\times m$ où $a_{i,j}=\left\{\begin{array}{ll}
		 	1 & \text{si le n\oe ud } i \in \mathcal N_j\\
		 	0 & \text{sinon}
		 \end{array}\right.$
		 
		 $x_j$ variable binaire de décision telle que $x_j=\left\{\begin{array}{ll}
		 	1 & \text{si la zone } R_j \text{ est dans le chemin minimum}\\
		 	0 & \text{sinon}
		 \end{array}\right.$
		 
		 La fonction objective devient alors $\min\sum_{j=1}^mx_j$ (on minimise le nombre de zones d'arrêt) avec une contrainte: $\sum_{j=1}^ma_{i,j}x_j\geq 1; \forall i\in \left\{1, \dots ,n\right\}$ (chaque chargeur appartient à au moins une zone d'arrêt faisant parti du chemin considéré).
		 
	\section{TSP}
		Le \gls{tsp} \cite{wiki:tsp} est un problème très connu dans la communauté scientifique concernant l'optimisation combinatoire.
		Il pose la question suivante: << Ayant un liste de villes et connaissant les distances entre elles, quelle est la plus courte distance telle qu'un voyageur visite chaque ville une seule fois et revienne à sont point de départ? >>.
		De manière parallèle on peut aussi s'intéresser au chemin tel que le temps de parcours est le minimum.
		Cela s'applique bien à notre problème, les villes correspondent aux différents points d'arrêt et le voyageur est un \gls{mc}.
		
		Ce problème fait cependant partie de la classe NP-difficile.
		C'est à dire qu'il n'existe pas d'algorithme déterministique résolvable en temps polynomial.
		Il y a donc un choix à faire quant aux solutions que nous voulons obtenir: peu de temps mais une solution qui peut être loin de l'optimal, ou beaucoup de temps de recherche avec une solutions plus proche de l'optimal.
		
		Dans notre cas nous devons réaliser la tournée de nos \glspl{mc} de manière rapide, le premier choix sera donc de préférence.
		
		Le problème se traduit par un model \gls{ilp}.
		On numérote les villes $1, \dots, n$ et définissons $x_{i,j}=\left\{\begin{array}{ll}
				1 & \text{il existe un chemin de } i \text{ à }j\\
				0 & \text{sinon}
			\end{array}\right.$
			
		En posant $i=1,\dots,n$, $u_i$ une variable muette et $c_{i,j}$ la distance entre la ville $i$ et $j$ on définit le problème avec la fonction objectif suivante:
		\begin{align}
			\label{eq:eq1}
			\min\sum_{i=1}^n\sum_{j=1\atop j\neq i}^n c_{i,j}x_{i,j}
		\end{align}
		
		et avec comme contraintes:
		\begin{align}
			\label{eq:eq2}
			0 \leq x_{i,j} &\leq 1 &&\\
			u_i&\in\zz &&\nonumber \\
			\label{eq:eq3}
			\sum_{i=1\atop i\neq j}^n x_{i,j} &= 1 && \forall j\in \left\{ 1, \dots , n\right\}\\
			\label{eq:eq4}
			\sum_{j=1\atop j\neq i}^n x_{i,j} &= 1 && \forall i\in \left\{ 1, \dots , n\right\}\\
			\label{eq:eq5}
			u_i-u_j+nx_{i,j}&\leq n-1 && 2\leq i\neq j\leq n \\
			\label{eq:eq6}
			0\leq u_i &\leq n-1 && 2\leq i\leq n
		\end{align}
		
		L'\autoref{eq:eq1} définit notre fonction objectif cherchant à minimiser la distance parcourue.
		Si l'on veut changer la métrique à réduire, il suffit de changer ce que représente $c_{i,j}$.
		Dans notre cas cela pourrait être le temps de parcours entre deux n\oe uds.
		
		L'\autoref{eq:eq2} nous permet de restreindre $x_{i,j}$ aux valeurs $0$ et $1$ (on est en nombre entiers).
		
		Les équations \autoref{eq:eq3} et \autoref{eq:eq4} comptent respectivement le nombre de chemins sortants ou entrant sur un n\oe ud donné.
		Ce nombre doit être égal à $1$ pour n'avoir qu'un seul chemin passant par chaque point.
		
		Enfin les équations \autoref{eq:eq5} et \autoref{eq:eq6} assurent qu'il n'y ait qu'un seul chemin parcourant l'ensemble des n\oe uds (et non pas plusieurs chemins disjoints).
		
	
	\section{TSPMTW}
		Le \gls{tspmtw} est similaire au \gls{tsp} mais introduit une contrainte supplémentaire.
		Le << MTW >> supplémentaire dans le nom indique << multiple time window >> soit << fenêtre de temps multiple >> et c'est sur ce concept que la contrainte supplémentaire va se baser.
		
		Le principe est de définir:
		\begin{easylist}
			@ Une (ou plusieurs) fenêtre(s) de temps par n\oe ud dans lesquelles ce dernier est disponible.
			@ Un temps de service $\beta_i$ correspondant au temps d'arrêt nécessaire pour le n\oe ud $i$.
		\end{easylist}

		\img{tspmtw.png}{Illustration d'une fenêtre de temps (\href{https://acrogenesis.com/or-tools/documentation/user_manual/manual/tsp/tsptw.html}{source})}{}
		 
		On peut observer tout en bas du schéma une fenêtre de temps.
		Cette dernière est représenté par une date de début et une date de fin $\left[ a_{i,j}; b_{i,j}\right]$ avec $i$ étant l'indice du n\oe ud et $j$ l'indice de la fenêtre.
		Ainsi en considérant plusieurs fenêtres de temps, l'interval de disponibilité d'un n\oe ud devient $\left[ a_i;b_i\right] =\bigcup_j\left[ a_{i,j}; b_{i,j}\right]$.
		
		Dans la timeline on observe deux valeurs: $t_i$ étant la date d'arrivé au n\oe ud et $s_i$ la date de début du service.
		Comme dit précédemment le temps de service correspond à $\beta_i$.
		
		Ainsi le temps total passé au n\oe ud $i$ correspond à la partie supérieure, prenant en compte le temps de service et le temps d'attente de la disponibilité du noeud.
		
		Le \gls{tspmtw} est utilisé dans notre cas afin d'éviter la surcharge des \glspl{emr}.
		En effet, chaque n\oe ud début avec une fenêtre de temps $\left[ a_i;b_i\right] = \left[ 0; +\infty\right[$ puis à chaque chargement de ce dernier par un chargeur on retire la fenêtre de temps d'occupation.
		Notre fenêtre de temps devient alors $\left[ a_i;b_i\right] \longleftarrow \left[ a_i;b_i\right] \prive{\left[ s_j - \beta_i;s_j+\beta_j\right]}$, pour tout chargeur $j\neq i$ avec $j$ je chargeur qui vient de faire son service.
		De cette manière nous bannissons au fur et à mesure les moments où les \glspl{emr} nous posent problème.

\chapter{Analyse et conception}
	Dans ce chapitre nous allons nous intéresser à l'analyse de notre problème et à la conception de notre simulateur afin de pouvoir dégager des axes d'amélioration de l'algorithme qui pourront par la suite être testés dans le simulateur.

	\section{Analyse théorique}
		La première étape est donc l'analyse mathématique du problème.
		Si nous reprenons le schéma global de l'algorithme décrit dans le papier de Mme Rault \cite{Rault:chargers} (voir \autoref{fig:globalschema}) on remarque que ce dernier est découpé en plusieurs étapes, lesquelles font appel à leur propre algorithmes.
		Nous avons donc ici une opportunité d'amélioration à plusieurs niveau de manière indépendante.
		Cependant il ne faudra pas négliger les effets pouvant se produire si l'on combine plusieurs de ces améliorations ensemble (deux améliorations positives ensemble peuvent mener à une dégradation de manière générale).
		
		Nous allons ici détailler plusieurs axes.
		Ces derniers ne seront peut être pas tous testés par la suite.
		
		\subsection{Seuil $L_c$\label{sec:lc}}
			On rappelle que $L_c$ représente le signal critique envoyé par un capteur et déclenche une tournée des chargeurs.
			Nous allons nous intéresser à deux cas extrêmes:
			\begin{easylist}
				@ \textbf{$L_c$ proche de $L_r$ (seuil de demande de rechargement)}: Dans ce cas dès qu'un capteur juge qu'il nécessite d'être rechargé il lancera la tournée des chargeurs.
				Cela aura pour effet d'annuler la collecte d'une liste de capteur pour aller les recharger en groupe.
				Chaque tournée consistera à aller charger un capteur unique.
				Dans notre cas cela n'a que très peu d'intérêt.
				Il sera donc préférable de garder $L_c$ relativement distant de $L_r$ afin de pouvoir constituer des listes de n\oe uds à charger assez conséquentes.
				
				@ \textbf{$L_c$ proche de 0}: Une valeur proche de 0 lancerait les tournées lorsque le capteur est sur le point d'être hors d'usage.
				C'est encore une fois un point que nous souhaitons éviter.
				Il est donc nécessaire de s'écarter du 0 en prenant une marge suffisante pour couvrir le temps que les chargeurs vont mettre pour venir charger notre n\oe ud.
			\end{easylist}
			
			On remarque donc que la valeur de $L_c$ doit faire un compromis entre s'assurer que les pannes des capteurs sont inexistantes (valeur haute) et laisser de la marge pour grouper les appels des différents n\oe uds (valeur basse) tout en évitant toute pannes.
			
		\subsection{Seuil $L_r$}
			$L_r$ représente le seuil auquel un capteur va faire une demande de rechargement.
			De manière similaire avec $L_c$, nous allons nous intéresser au valeurs extrêmes.
			
			\begin{easylist}
				@ \textbf{$L_r$ proche de $L_C$}: De manière évidente c'est la même chose que $L_c$ proche de $L_r$; voir \autoref{sec:lc}.
				@ \textbf{$L_r$ proche de $C_i$ (capacité maximale d'un capteur)}: Cela va avoir pour effet d'enregistrer un n\oe ud comme nécessitant un rechargement alors que la batterie est encore relativement pleine.
				A cause de cet effet on risque de créer des tournées où la totalité des capteurs est présent.
				
				Dans ce cas la notion de << à la demande >> n'a plus de sens et revient à créer une tournée planifiée à l'avance et l'exécuter lors de la réception d'un $L_c$.
				
				Les batteries prendront surement moins de temps à charger mais d'un autre coté elles peuvent aussi être rechargés si elles se trouvent dans le rayon du chargeur lors d'un rechargement d'un n\oe ud voisin même si notre capteur n'avait pas fait de demande.
			\end{easylist}
			
			Tout comme $L_c$, il nous faut garder $L_r$ à une valeur distante de $L_c$ tout en laissant de la marge pour ne constituer des tournées qu'avec des capteurs ayant un réel besoin (et ainsi éviter les déplacements inutiles des chargeurs).
		
		\subsection{Influence du nombre de MCs}
			On peut avoir tendance à penser que plus nous augmentons le nombre de \glspl{mc} plus nous rendons notre système efficace car nous ajoutons de la capacité à traiter les capteurs en parrallèle.
			Cependant ce n'est pas toujours le cas.
			Deux raisons expliquant cela sont:
			\begin{easylist}
				@ En augmentant le nombre de \gls{mc}, on augmente aussi la consommation globale en énergie.
				En effet nous nécessitons de plus d'énergie pour déplacer l'ensemble des chargeurs.
				@ On augmente la complexité des \glspl{tspmtw} vis à vis des \glspl{emr}.
				Cela s'explique par le fait que plus l'on a de chargeurs, plus l'on à d'interférences possible entre ces derniers.
				Il se peut donc qu'avec trop de chargeurs on introduise un nombre conséquent de temps d'attente afin d'éviter des conflits.
			\end{easylist}
			
			Il va donc falloir que nous trouvons un nombre adéquat de chargeurs afin de ne pas surcharger la zone tout en en gardant un nombre suffisant pour pouvoir paralléliser nos rechargements.
		
		\subsection{Rayons de rechargement différents}
			Actuellement l'algorithme proposé ne prend en compte qu'un seul rayon de rechargement pour tous les capteurs.
			Cependant il pourrait être intéressant de considérer des chargeurs ayant des rayons différents.
			Cela pourrait peut-être améliorer dans certains cas l'algorithme de clustering.
			
			A terme cela pourrait réduire le temps d'attente en réduisant le nombre de zones en conflit.
			Cependant cela ajoute une complexité supplémentaire dans la génération de nos clusters.
			
			Il est cependant dans mon opinion pas très intéressant d'explorer cette piste.
			En effet comme précisé dans l'étude de l'art (\autoref{sec:clustering}), on suppose que le disque de rechargement $M$ est constant.
			Une manière simple de travailler avec des rayons différents est de poser $M=\min_{i}M_i$.
			Cette approche ne prend cependant pas avantage des rayons différentes.
			
			Une autre approche consisterai en une exploration de différentes solutions où les différents $M$ de chaque cluster prend une valeur parmi les $M_i$ disponibles.
			On peut imaginer utiliser des algorithmes génétiques ou autres afin de trouver une solution s'approchant de l'optimale.
			Cependant cette façon de procéder rajouter un nombre assez conséquent de répétitions de l'algorithme de clustering (avec différents $M$).
			L'ajout de cette complexité n'est probablement pas avantageuse comparée au gain minime de performance du système que l'on pourrai obtenir.
						
		\subsection{Modification de la fonction objectif des TPSMTWs}
			Un autre point sur lequel nous pouvons influencer est la façon dont sont généré les routes des chargeurs une fois que le premier tracé est défini.
			Nous utilisons pour le moment une fonction objectif minimisant le temps de parcours.
			Cependant on peut envisager de modifier cette dernière pour prendre en compte une combinaison du temps et de la distance.
			
			Les paramètre de la combinaison entre les deux variables reste à déterminer expérimentalement.
			Selon moi cela aura un impact que très minime.
			En effet le fait de minimiser la temps minimise aussi la distance parcourue d'une certaine manière puisque se déplacer prends du temps.
		
		\subsection{Modification de la méthode de clustering}
			La méthode utilisé pour le clustering est un point central concernant l'aspect << point-to-multipoint >> de nos chargeurs.
			En effet c'est ce dernier qui s'occupe de transformer notre liste de capteurs en un nombre réduit de points d'arrêt qui seront utilisés pour notre tournée.
			Cela nous permet d'obtenir un point précis d'arrêt ainsi qui de réduire le nombre d'arrêts.
			
			Actuellement la création de ces régions d'arrêt fait en sorte qu'un capteur se retrouve associé à au moins un point d'arrêt.
			Cependant il peut être aussi faire parti de plusieurs régions à la fois. 
			Ce point peut être très intéressant car de cette manière on peut considérer le rechargement d'un capteur depuis plusieurs zones.
			
			Cela est utile si l'on a un capteur fortement déchargé entouré de capteurs moyennement déchargés.
			Ainsi on commence par charger une partie des capteurs, dont celui fortement déchargé.
			Dès que les capteurs moyennement déchargés sont complètement chargés, on change de zone pour recharger une autre partie moyennement déchargée tout en continuant le rechargement du capteur fortement déchargé (et qui doit donc être moyennement déchargé à ce moment).
			
			Voici une représentation de la situation.
			On dispose de deux disques (bleu et cyan) qui ont été construits par notre algorithme de clustering.
			Le centre de chacun d'entre eux représente un point d'arrêt.
			
			Les yeux représentes nos différents capteurs (vert: chargés, orange: moyennement déchargés, rouge: fortement déchargés).
			
			Le véhicule rose représente un chargeur.
			
			On peut imaginer le premier état comme étant le rechargement du disque bleu.
			
			\img{multi1.png}{Etat A}{width=10cm}
			
			Enfin lorsque les capteurs orange du disque bleu sont chargés, le véhicule se déplace dans le disque cyan et effectue le chargement.
			
			\img{multi2.png}{Etat B}{width=10cm}
			
			Notre n\oe ud originellement rouge a donc été chargé en deux phases, réduisant ainsi le temps de tournée du véhicule.
			
			Afin de prendre en compte cette appartenance multiple, il nous faut adapter le step 1 du papier de Mme Rault \cite{Rault:chargers} (Fig. 2.).
			La méthode actuelle consiste à prendre pour chaque région $R_j$ $t_j=\max_{i\in R_j}t_{j,i}$ où $t_{j,i}$ représente le temps de charge d'un capteur $i$ appartenant à la région $R_j$.
			
			Afin de prendre en compte le principe de rechargement depuis plusieurs zones, on propose de modifier l'algorithme permettant de calculer le temps d'arrêt d'une région:
			
			\begin{algorithm}
				\caption{Calcul des temps de recharge à chaque point d'arrêt en prenant en compte les n\oe uds présents dans plusieurs régions}
  				\label{alg:algorithm1}
  				\hspace*{\algorithmicindent} \textbf{Input:}
  				The set $S=\left\{1,\dots, m\right\}$ of $m$ regions obtained from the 2 firsts steps of the first step. The set $S_j=\left\{1,\dots ,n_j\right\}$ of $n_j$ sensors inside a region $R_j$ with their charging time $t_i$, $\forall i\in S$. The set $K$ which for each sensor contains a set containing each regions the sensor is in.
				\begin{algorithmic}[1]
					\For{$j\in S$}
						\State $P_j\leftarrow \left\{\right\}$
						\State $t_j\leftarrow 0$
						\For{$i\in S_j$}
							\If{$\text{card}\left(K_i\right)>1$}
								\State $P_j\leftarrow P_j\cup\left\{ i\right\}$
								\State $K_i \leftarrow K_i\prive{j}$
							\Else
								\State $t_j \leftarrow \max\left( t_j, t_{j,i}\right)$
							\EndIf
						\EndFor
						\For{$i\in P_j$}
							\State $t_{j,i}\leftarrow t_{j,i} - t_j$
						\EndFor
					\EndFor
				\end{algorithmic}
			\end{algorithm}
 

		\subsection{Méthode de répartition des points d'arrêts}
			Lors de l'assignement des premiers clusters à chaque chargeur, il peut être intéressant d'utiliser une méthode qui n'est pas aléatoire.
			En effet si l'on se retrouve avec des chargeurs qui doivent aller dans des régions voisines dès le départ n'est peut être pas optimal.
			En revanche répartir ces premières destinations au travers de la zone de capteurs peut améliorer la distance parcourue afin de couvrir cette région entièrement.
		
		\subsection{Eléments d'analyse}
			Nous allons dans un premier temps s'intéresser aux influence des paramètres suivants:
			\begin{easylist}
				@ Seuil $L_c$.
				@ Seuil $L_r$.
				@ Nombre de \glspl{mc}.
				@ Modification de la méthode de clustering.
				@ Modification de la fonction objectif des \glspl{tspmtw}.
			\end{easylist}
			
	\section{Analyse logicielle}
		Afin de réaliser la partie logicielle, c'est à dire le simulateur, on propose de suivre un diagramme de classe similaire à celui ci-dessous.
		
		\img{ClassDiagram.png}{Diagramme de classes simplifié}{}
		
		On y retrouves trois parties principales:
		\begin{easylist}[itemize]
			@ Configuration: rassemble toutes les classes qui serviront à paramétrer notre simulateur.
			@ Simulator: contient tout les éléments liés à la simulation cela passe par chargeurs, capteurs, systèmes de routage mais aussi par des évènements qui permettront de faire avancer la simulation.
			@ Metrics: concerne toute la partie de collecte des informations sur le système afin de les restituer et agréger par la suite. 	
		\end{easylist}

		\subsection{Configuration}
			\img{config.png}{Partie configuration}{}
			
			La partie configuration va comporter une classe principale permettant de lire un fichier JSON qui mettra par la suite un objet Environment disponible au travers d'un getter.
			Ce chargement de paramètres doit être dynamique en autorisant l'instantiation de classes à partir de leur noms et de paramètres.
			Pour cela on créera une interface << JSONParsable >> permettant à un objet lisible depuis le JSON de récupérer les paramètres dont il a besoin.
			
			Si on problème survient durant la lecture de la configuration, une exception SettingsParserException sera levée en indiquant où se situe le problème.
		
		\subsection{Simulator}
			\todooi{LATER}
			Le diagramme de classes ci-dessous nous montre la partie simulateur dans son état le plus simple -- aucun algorithme de routage n'a été ajouté et les capteur ne font que se décharger.
			
			\img{simulator.png}{Partie simulator}{}
			
			La partie supérieure concerne le << modèle >> avec les différents éléments de notre environnement (router, charger, sensor).
			Cependant si par la suite nous voulons ajouter des éléments personnalisés, il suffit d'étendre la classe Identifiable et ajouter ces éléments dans l'environnement.
			Nous permettons donc grâce à cette interface une flexibilité sur les éléments de la simulation.
			
			La partie inférieure se focalise plus sur la simulation en elle même avec notre échéancier et les différents évènements qui l'entoure.
			De base seul les évènements Start (début), End (Fin) et Discharge (déchargement des capteurs) sont présents.
			Cependant lors de l'ajout de nouveaux éléments Identifiables, ces derniers pourront créer de nouveaux évènements (SimulationEvent) et le simulateur les traitera aussi.
			Par exemple on créé une classe LrLcSensor qui extend Sensor, et dès que le niveau de batterie est inférieur à $L_r$ ce dernier va créer un évènement LrEvent.
		
		\subsection{Metrics}
			La collecte des métriques est un point important de la simulation et doit permettre de collecter un grand nombres de données.
			
			Pour cela on propose de suivre un design pattern de producteur consommateur.
			Les producteurs seront des éléments de la simulation qui généreront des évènements indiquant un changement dans l'état des variables.
			Les consommateurs vont par la suite consommer ces évènements, ne garder que ceux qui les intéressent, et traiter ce changement.
			
			Les consommateurs seront aussi responsables d'écrire les résultats dans les différents fichiers de sortie.
			
		\subsection{Diagramme complet}
			Voici le diagramme de classes complet dans l'état actuel (la partie métriques n'est pas implémentée et l'algorithme de routage non fini).
			
			\img{diagramfull.png}{Diagramme de classes complet}{}
	
\chapter{Mise en œuvre}
	\todooi{S10}
	
\chapter{Bilan et conclusion}
	\todooi{S10}
	
\appendix
\chapter{Découverte du sujet}
	\img[changes]{changes.png}{Première compréhension du sujet}{}
	
\chapter{Planification\label{sec:plannification}}
	Toute la planification du projet va se faire au travers d'un système de cartes pouvant se retrouver dans 3 états différents:
	\begin{easylist}
		@ Non commencée
		@ En cours
		@ Terminée	
	\end{easylist}
	
	Ce procédé peut sembler très différent de l'utilisation d'un diagramme de Gantt mais est en faite assez similaire si l'on oubli la partie présentation.
	En effet, on découpe notre projet en une suite de tâches qui devront être réalisées dans un ordre donné. Chacune d'entre elles va comporter une date de fin qui sera à respecter et peut éventuellement contenir des sous-tâches plus précises.
	
	Toutes ces tâches peuvent elles-même être regroupées dans une << milestone >> permettant d'avoir une vue plus globale sur les tâches à réaliser pour une partie donnée.
	
	Ce choix me parait être intéressant car on retrouve toujours la notion du temps tout comme dans un Gantt mais il est plus facile d'insérer de nouvelles tâches au besoin du fait que ce système met l'accent sur les dates de fin au lieu de dates de début et fin.
	De plus de tels outils s'intègrent parfaitement dans les outils VCS modernes tels que GitLab ou GitHub.
	
	Nous allons donc détailler l'outils qui a été utilisé (GitLab) puis décrire les différentes tâches identifiées.

	\section{Outils}
		Commençons tout d'abord par présenter le système de cartes qui a été utilisé.
		Ce dernier est proposé par GitLab, un site web mettant à disposition des dépôts Git permettant de versionner son code pour garder les traces de toutes modifications.
		
		Le plus souvent ces entreprises mettent aussi à disposition un système de gestion de << tickets >>.
		
		\img{Issue.png}{Exemple d'une issue}{}
		
		Un ticket représente une tâche à effectuer et comporte plusieurs éléments la définissant:
		\begin{easylist}
			@ Titre.
			@ Description: Permet de décrire plus précisément ce qui est attendu.
			@ Assignee: La personne assignée sur la tâche. Dans notre cas cela n'a pas trop de sens puisque je suis tout seul mais nous utiliserons ce système pour différencier une tâche non commencée (non assignée) d'une tâche en cours (assignée).
			@ Milestone: Représente l'étape du projet qui englobe la tâche. Nous verrons par la suite le tableau de gestion des tâches par milestone.
			@ Time tracking: Permet d'indiquer le temps que l'on a passé sur une tâche. Cela peut être utile pour estimer les prochaines tâches ou tout simplement vérifier que le temps passé sur une tâche ne devient pas excessif.
			@ Due date: La date due.
			@ Label: Représente une liste de labels que l'on peut appliquer afin de catégoriser la tâche.
		\end{easylist}
		
		De cette manière on peut organiser nos tâches tout en laissant une flexibilité sur l'ordre dans lesquels elles sont réalisés (sauf si une tâche en requiert une autre) du temps que les tâches sont réalisées avant la date de fin.
		
		De plus le regroupement de nos tâches en milestones nous permet d'avoir une vue plus focalisé sur le travail que nous avons à faire à un moment donné.
		La vue ressemble à l'image ci-dessous:
		\img{Milestone.png}{Vue milestone}{} 
		
		Comme on peut le voir, la plus grosse partie représente les différentes tâches d'une étape. Cela est très pratique pour avoir une vue générale de ce qu'il reste à faire.
	
	\section{Découpage des tâches}
		\subsection{Gestion de projet et version}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de déterminer la méthode et les outils qui seront utilisés pour la gestion de projet.
				@ \textbf{Estimation de charge}:
				
				1 jour/homme.
			\end{easylist}
			
		\subsection{Compréhension des objectifs et du contexte}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de prendre en main le sujet en découvrant le papier déjà réalisé et prenant connaissance des objectifs.
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Rédaction du cahier de spécification}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rédiger la partie spécification du rapport. Ce dernier sera amélioré au cours du projet.
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Etudier l’existant}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rentrer plus en détail dans le papier de Mme Rault tout en analysant les resources utilisés afin d'envisager des premières pistes d'amélioration.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
			\end{easylist}
			
		\subsection{Etat de l'art}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de rédiger l'état de l'art afin de rendre compte des méthodes utilisés dans le papier.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
			\end{easylist}
			
		\subsection{Analyse des améliorations}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de présenter une analyse des améliorations possibles de l'algorithme de génération des tournées.
				@ \textbf{Estimation de charge}:
				
				10 jour/homme.
			\end{easylist}
			
		\subsection{Analyse du simulateur}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de présenter une première analyse de la conception du simulateur.
				@ \textbf{Estimation de charge}:
				
				5 jour/homme.
			\end{easylist}
			
		\subsection{Finalisation du rapport S9}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de finaliser le rapport pour le S9.
				@ \textbf{Estimation de charge}:
				
				5 jour/homme.
				@ \textbf{Livrable}:
				
				Rapport final du S9.
				@ \textbf{Date limite}:
				
				08/12/2018
			\end{easylist}
			
		\subsection{Préparation de la soutenance S9}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de préparer la soutenance du S9.
				@ \textbf{Estimation de charge}:
				
				2 jour/homme.
				@ \textbf{Livrable}:
				
				Exposé PowerPoint.
				@ \textbf{Date limite}:
				
				12/12/2018
			\end{easylist}
			
		\subsection{Réalisation du simulateur}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de réaliser le simulateur.
				Elle sera effectuée en plusieurs sprints.
				@ \textbf{Estimation de charge}:
				
				12 jour/homme.
				@ \textbf{Livrable}:
				
				Plusieurs versions de l'application.
			\end{easylist}
			
		\subsection{Expérimentation des solutions proposées}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de réaliser les tests sur les améliorations proposées précédemment.			
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Interprétation des résultats expérimentaux}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but d'analyser les résultats obtenus et les mettre en parallèle avec la solution d'origine.			
				@ \textbf{Estimation de charge}:
				
				4 jour/homme.
			\end{easylist}
			
		\subsection{Finalisation du rapport S10}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de finaliser le rapport du S10.			
				@ \textbf{Estimation de charge}:
				
				6 jour/homme.
				@ \textbf{Livrable}:
				
				Rapport final du S10.
				@ \textbf{Date limite}:
				
				??/04/2018 \todooi{Change date when known}
			\end{easylist}
			
		\subsection{Préparation de la soutenance du S10}
			\begin{easylist}
				@ \textbf{Description de la tâche}:
				
				Cette tâche à pour but de préparer la soutenance du S10.
				@ \textbf{Estimation de charge}:
				
				3 jour/homme.
				@ \textbf{Livrable}:
				
				Exposé PowerPoint.
				@ \textbf{Date limite}:
				
				??/04/2019 \todooi{Change date when known}
			\end{easylist}

	
\chapter{Spécifications fonctionnelles}
	Nous allons dans cette partie introduire les fonctions principales qui peuvent être utilisées dans le simulateur.
	
	\section{Importation des paramètres}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet de lire le fichier d'entrée contenant les paramètres de la simulation.
			@ \textbf{Présentation}:
			
			- Nom: SimulationParameters.fromJSON
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			Afin de pouvoir personnaliser la simulation on laisse l'utilisateur fournir un fichier de configuration.
			Ce dernier permet de préciser le nombre, type et comportement de différents éléments de la simulation.
			Plus de détails en \autoref{sec:jsoninput}.
			@ \textbf{Description précisée}:
			
			- Entrée: Le fichier à lire.
			
			- Sortie: Un objet SimulationParameters initialisé.
			
			- Exception: Si le fichier n'existe pas ou est illisible.
		\end{easylist}
		
	\section{Module de simulation}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet de lancer une simulation afin d'obtenir des métriques.
			@ \textbf{Présentation}:
			
			- Nom: Simulation.run
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			La simulation aura pour but de simuler un environnement de capteurs avec les différents chargeurs mobiles.
			Cette partie devra prendre en compte la configuration afin de lancer la simulation voulue.
			De plus les implémentations personnalisées (capteurs, chargeurs, méthode de routage) devront être prises en compte.
			
			@ \textbf{Description précisée}:
			
			- Entrée: Un objet SimulationParameters.
			
			- Sortie: $\emptyset$.
			
			- Exception: $\emptyset$.
			
			- Interfaces: Permet une interfaçage avec les classes générant les métriques afin de leur envoyer des informations sur l'état du système.
		\end{easylist}

	\section{Visualisation des résultats}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette partie permet de générer et afficher les résultats sous forme de graphiques dans une fenêtre.
			@ \textbf{Présentation}:
			
			- Nom: -
			
			- Priorité: Modéré
			@ \textbf{Description}:
			
			Afin de pouvoir observer les résultats on envisage d'afficher dans un premier temps les résultats sous forme de graphiques.
			De cette manière on peut juger si la simulation vaut le coup d'être exportée.
			@ \textbf{Description précisée}:
			
			- Entrée: Les données de la métrique enregistré.
			
			- Sortie: Un graphique.
			
			- Exception: $\emptyset$.
		\end{easylist}
		
	\section{Ecriture des résultats}
		\begin{easylist}[enumerate]
			@ \textbf{Identification}:
			
			Cette fonction permet d'écrire le fichier de sortie contenant les résultats de la simulation.
			@ \textbf{Présentation}:
			
			- Nom: \todooi{Function name}
			
			- Priorité: Primordiale
			@ \textbf{Description}:
			
			Afin de pouvoir stocker et comparer par la suite les résultats on propose de les enregistrer dans des fichiers.
			Plus de détails en \autoref{sec:csvoutput}.
			@ \textbf{Description précisée}:
			
			- Entrée: Les métriques à sauvegarder, un dossier de sortie.
			
			- Sortie: Des fichiers CSV.
			
			- Exception: Si les fichiers ne peuvent être écrits.
		\end{easylist}
	
\chapter{Spécifications non fonctionnelles}
	\section{Analyse de l'algorithme}
		D'un point de vue algorithmique, des améliorations de l'algorithme proposé par Mme Rault \cite{Rault:chargers} devront être proposés et détaillés.
			
		Ce seront ces dernières qui seront par la suite testées avec le simulateur et conduiront à une conclusion quand à l'efficacité de ces dernières.
		
		On considérera qu'un algorithme est amélioré si le temps de rechargement est diminuée sur au moins un type d'instance.
		
		Les instances à utiliser seront fournies par Mme Rault.
		Certaines d'entre elles pourront comporter des valeurs aléatoires qui seront définies dans un interval.
		Dans ce cas la simulation sera jouée plusieurs fois et nous garderons la moyenne des résultats comme étant notre résultat final.

	\section{Contraintes de développement et conception}
		\begin{easylist}[itemize]
			@ Language: Java 11
			@ Plateformes cibles: Windows, OSX, Linux
		\end{easylist}
		
	\section{Contraintes de fonctionnement et d'exploitation}
		\subsection{Performances}
			\begin{easylist}
				@ Du point de vue environnement, le programme doit être utilisable dans la majorité des systèmes d'exploitation.
				Grâce à la JVM cela devrait être transparent au niveau du codage.
			
				@ D'un point de vue utilisateur il faut que le programme réalise la simulation dans un temps non infini.
				Il faut donc un système permettant de limiter le nombre d'itération du programme.
				On propose une méthode les limitant dans le temps en définissant une date d'arrêt.
			\end{easylist}
			
		\subsection{Capacité}
			\begin{easylist}
				@ Afin de pouvoir obtenir une vision détaillé du processus de la simulation, on met à disposition les logs du programme au travers d'un fichier.
				Pour éviter de saturer l'espace mémoire, on limite les fichiers de logs à 10Mb et ne gardons que les logs des 30 derniers jours.
			
				@ De plus, le grand nombre d'itérations entraine un grand nombre de donnée accumulée.
				Il sera donc nécessaire de ne pas tout garder en mémoire RAM afin d'éviter des dépassements.
			\end{easylist}

		\subsection{Contrôlabilité}
			\begin{easylist}
				@ La simulation doit produire les même résultats pour la même configuration.
				Dans le cas d'un algorithme incluant un choix aléatoire on proposera à l'utilisateur de configurer la graine de génération de ces nombres.
				Cela permet à l'utilisateur de reproduire une simulation et analyser les logs si les résultats paraissent aberrants.
			\end{easylist}
					
\chapter{Cahier du développeur}
	\todooi{S10}
	\section{Diagramme de classe}
	\section{Description des classes}
	\section{Description des fichiers I/O}
		\subsection{Fichiers de configuration}
		\subsection{Fichiers résultats}
	\section{Structure du projet}
	
\chapter{Document d'installation du projet}
	\todooi{S10}
	\section{Utilisation simple}
	\section{Utilisation développeur}

\chapter{Document d'utilisation du projet}
	\section{Fichier de configuration\label{sec:jsoninput}}
		Le fichier d'entrée du simulateur doit être sous le format JSON.
		Nous aurons donc une structure semblable à celle-ci:
		\jsonsourcefile{../Simulator/src/test/resources/settings/settings1.json}
		
		La racine du fichier est un objet JSON contenant plusieurs éléments:
		\begin{easylist}[itemize]
			@ \textbf{seed}: Correspond à la graine utilisée pour la génération de nombres aléatoires. Si cette dernière n'est pas précisée, une graine basée sur le temps actuel sera utilisée.
			@ \textbf{end}: La date de fin de la simulation. 
			@ \textbf{environment}: Une liste d'objets définissant les objets présents dans notre simulation. Ces derniers seront décris plus en détail en \autoref{sec:jsonconf:env}.	
		\end{easylist}
		
		\subsection{Environment\label{sec:jsonconf:env}}
			Les objets présents dans cette liste peuvent être très variés.
			De base l'application propose quelques capteurs et quelques chargeurs mais il est aussi possible d'utiliser certains objets qui ont étés créés par la suite afin de traiter le problème avec un algorithme différent.
			Cependant tous ces objets suivent la même forme:
			\begin{easylist}[itemize]
				@ \textbf{class}: La classe de l'objet dans le code JAVA.
				@ \textbf{count}: Le nombre d'objets de ce type à créer avec les paramètres donnés (si les paramètres doivent être différents pour chaque éléments, il faut que la classe JAVA gère la génération d'un nombre aléatoire dans un interval (qui sera passé en paramètres) ou il faut déclarer plusieurs objets dans le JSON).	
				@ \textbf{parameters}: Les paramètres pour initialiser l'objet. Ces derniers sont différents pour chaque éléments que nous voulons utiliser (ceux fournis de base sont décris en \autoref{sec:jsonconf:params}).
			\end{easylist}

		\subsection{Paramètres\label{sec:jsonconf:env}}
			\subsubsection{Chargers}
				\paragraph{fr.mrcraftcod.simulator.chargers.Charger}
					\begin{easylist}[itemize]
						@ \textbf{radius}: Nombre réel, le rayon de rechargement du chargeur.
						@ \textbf{transmissionPower}: Nombre réel, la puissance de transmission.
						@ \textbf{maxCapacity}: Nombre réel, la capacité maximale de la batterie.
						@ \textbf{currentCapacity}: Nombre réel, la capacité de départ de la batterie.
						@ \textbf{speed}: La vitesse de déplacement.
					\end{easylist}
			
			\subsubsection{Capteurs}
				\paragraph{fr.mrcraftcod.simulator.sensors.Sensor\label{sec:jsonconf:sensor}}
					\begin{easylist}[itemize]
						@ \textbf{powerActivation}: Nombre réel, la puissance minimale pour activer le rechargement.
						@ \textbf{position}: objet JSON (\autoref{sec:jsonconf:pos}), la position.
						@ \textbf{maxCapacity}: Nombre réel, la capacité maximale de la batterie.
						@ \textbf{currentCapacity}: Nombre réel, la capacité de départ de la batterie.
						@ \textbf{dischargeSpeed}: La vitesse de déchargement.
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.rault.sensors.LrLcSensor}
					\begin{easylist}[itemize]
						@ Pareil que fr.mrcraftcod.simulator.sensors.Sensor (\autoref{sec:jsonconf:sensor}).
						@ \textbf{lc}: Nombre réel, la valeur de lc.
						@ \textbf{lr}: Nombre réel, la valeur de lr.
					\end{easylist}
					
			\subsubsection{Routing}
				\paragraph{fr.mrcraftcod.simulator.rault.routing.RaultRouting}
					\begin{easylist}[itemize]
						@ $\emptyset$
					\end{easylist}
					
			\subsubsection{Position\label{sec:jsonconf:pos}}
				\paragraph{fr.mrcraftcod.simulator.positions.Position}
					\begin{easylist}[itemize]
						@ \textbf{x}: Nombre entier, la position $x$.
						@ \textbf{y}: Nombre entier, la position $y$.
					\end{easylist}
					
				\paragraph{fr.mrcraftcod.simulator.positions.RandomPosition}
					\begin{easylist}[itemize]
						@ \textbf{max}: Nombre entier, la borne maximum pour la génération aléatoire. Les valeurs $x$ et $y$ seront comprises entres $-max$ et $+max$.
					\end{easylist}

	\section{Fichier de sortie\label{sec:csvoutput}}
		Nous retenons deux types de fichiers de sortie.
		Les premiers sont des images représentant des graphes de l'évolution de différentes métriques. Ces dernières pourront êtres définies par l'utilisateur dans le code mais certaines seront fournies de base:
		\begin{easylist}[itemize]
			@ Pourcentage de batterie des capteurs.
			@ Nombre de capteurs déchargés.
			@ Nombre de chargeurs utilisés.
			@ Pourcentage d'utilisation des chargeurs.
			@ Nombre de requêtes Lr en attente.
			@ Temps de calcul de la tournée.
		\end{easylist}
		
		De plus ces données seront aussi fournies sous un format CSV afin d'avoir un accès aux valeurs précises et pouvoir les exploiter dans un autre programme ou bien un tableur.


\chapter{Cahier des tests}
	\todooi{S10}

\end{document}